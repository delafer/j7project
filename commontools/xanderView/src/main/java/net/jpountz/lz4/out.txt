/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.io.EOFException;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.Checksum;
import net.jpountz.lz4.LZ4BlockOutputStream;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4FastDecompressor;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.StreamingXXHash32;
import net.jpountz.xxhash.XXHashFactory;

public final class LZ4BlockInputStream
extends FilterInputStream {
    private final LZ4FastDecompressor decompressor;
    private final Checksum checksum;
    private byte[] buffer;
    private byte[] compressedBuffer;
    private int originalLen;
    private int o;
    private boolean finished;

    public LZ4BlockInputStream(InputStream in, LZ4FastDecompressor decompressor, Checksum checksum) {
        super(in);
        this.decompressor = decompressor;
        this.checksum = checksum;
        this.buffer = new byte[0];
        this.compressedBuffer = new byte[LZ4BlockOutputStream.HEADER_LENGTH];
        this.originalLen = 0;
        this.o = 0;
        this.finished = false;
    }

    public LZ4BlockInputStream(InputStream in, LZ4FastDecompressor decompressor) {
        this(in, decompressor, XXHashFactory.fastestInstance().newStreamingHash32(-1756908916).asChecksum());
    }

    public LZ4BlockInputStream(InputStream in) {
        this(in, LZ4Factory.fastestInstance().fastDecompressor());
    }

    @Override
    public int available() throws IOException {
        return this.originalLen - this.o;
    }

    @Override
    public int read() throws IOException {
        if (this.finished) {
            return -1;
        }
        if (this.o == this.originalLen) {
            this.refill();
        }
        if (this.finished) {
            return -1;
        }
        return this.buffer[this.o++] & 255;
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        SafeUtils.checkRange(b, off, len);
        if (this.finished) {
            return -1;
        }
        if (this.o == this.originalLen) {
            this.refill();
        }
        if (this.finished) {
            return -1;
        }
        len = Math.min(len, this.originalLen - this.o);
        System.arraycopy(this.buffer, this.o, b, off, len);
        this.o+=len;
        return len;
    }

    @Override
    public int read(byte[] b) throws IOException {
        return this.read(b, 0, b.length);
    }

    @Override
    public long skip(long n) throws IOException {
        if (this.finished) {
            return -1;
        }
        if (this.o == this.originalLen) {
            this.refill();
        }
        if (this.finished) {
            return -1;
        }
        int skipped = (int)Math.min(n, (long)(this.originalLen - this.o));
        this.o+=skipped;
        return skipped;
    }

    private void refill() throws IOException {
        this.readFully(this.compressedBuffer, LZ4BlockOutputStream.HEADER_LENGTH);
        for (int i = 0; i < LZ4BlockOutputStream.MAGIC_LENGTH; ++i) {
            if (this.compressedBuffer[i] == LZ4BlockOutputStream.MAGIC[i]) continue;
            throw new IOException("Stream is corrupted");
        }
        int token = this.compressedBuffer[LZ4BlockOutputStream.MAGIC_LENGTH] & 255;
        int compressionMethod = token & 240;
        int compressionLevel = 10 + (token & 15);
        if (compressionMethod != 16 && compressionMethod != 32) {
            throw new IOException("Stream is corrupted");
        }
        int compressedLen = SafeUtils.readIntLE(this.compressedBuffer, LZ4BlockOutputStream.MAGIC_LENGTH + 1);
        this.originalLen = SafeUtils.readIntLE(this.compressedBuffer, LZ4BlockOutputStream.MAGIC_LENGTH + 5);
        int check = SafeUtils.readIntLE(this.compressedBuffer, LZ4BlockOutputStream.MAGIC_LENGTH + 9);
        assert (LZ4BlockOutputStream.HEADER_LENGTH == LZ4BlockOutputStream.MAGIC_LENGTH + 13);
        if (this.originalLen > 1 << compressionLevel || this.originalLen < 0 || compressedLen < 0 || this.originalLen == 0 && compressedLen != 0 || this.originalLen != 0 && compressedLen == 0 || compressionMethod == 16 && this.originalLen != compressedLen) {
            throw new IOException("Stream is corrupted");
        }
        if (this.originalLen == 0 && compressedLen == 0) {
            if (check != 0) {
                throw new IOException("Stream is corrupted");
            }
            this.finished = true;
            return;
        }
        if (this.buffer.length < this.originalLen) {
            this.buffer = new byte[Math.max(this.originalLen, this.buffer.length * 3 / 2)];
        }
        switch (compressionMethod) {
            case 16: {
                this.readFully(this.buffer, this.originalLen);
                break;
            }
            case 32: {
                if (this.compressedBuffer.length < this.originalLen) {
                    this.compressedBuffer = new byte[Math.max(compressedLen, this.compressedBuffer.length * 3 / 2)];
                }
                this.readFully(this.compressedBuffer, compressedLen);
                try {
                    int compressedLen2 = this.decompressor.decompress(this.compressedBuffer, 0, this.buffer, 0, this.originalLen);
                    if (compressedLen == compressedLen2) break;
                    throw new IOException("Stream is corrupted");
                }
                catch (LZ4Exception e) {
                    throw new IOException("Stream is corrupted", e);
                }
            }
            default: {
                throw new AssertionError();
            }
        }
        this.checksum.reset();
        this.checksum.update(this.buffer, 0, this.originalLen);
        if ((int)this.checksum.getValue() != check) {
            throw new IOException("Stream is corrupted");
        }
        this.o = 0;
    }

    private void readFully(byte[] b, int len) throws IOException {
        int r;
        int read;
        for (read = 0; read < len; read+=r) {
            r = this.in.read(b, read, len - read);
            if (r >= 0) continue;
            throw new EOFException("Stream ended prematurely");
        }
        assert (len == read);
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
    }

    @Override
    public void reset() throws IOException {
        throw new IOException("mark/reset not supported");
    }

    public String toString() {
        return this.getClass().getSimpleName() + "(in=" + this.in + ", decompressor=" + this.decompressor + ", checksum=" + this.checksum + ")";
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.zip.Checksum;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.StreamingXXHash32;
import net.jpountz.xxhash.XXHashFactory;

public final class LZ4BlockOutputStream
extends FilterOutputStream {
    static final byte[] MAGIC = new byte[]{76, 90, 52, 66, 108, 111, 99, 107};
    static final int MAGIC_LENGTH = MAGIC.length;
    static final int HEADER_LENGTH = MAGIC_LENGTH + 1 + 4 + 4 + 4;
    static final int COMPRESSION_LEVEL_BASE = 10;
    static final int MIN_BLOCK_SIZE = 64;
    static final int MAX_BLOCK_SIZE = 33554432;
    static final int COMPRESSION_METHOD_RAW = 16;
    static final int COMPRESSION_METHOD_LZ4 = 32;
    static final int DEFAULT_SEED = -1756908916;
    private final int blockSize;
    private final int compressionLevel;
    private final LZ4Compressor compressor;
    private final Checksum checksum;
    private final byte[] buffer;
    private final byte[] compressedBuffer;
    private final boolean syncFlush;
    private boolean finished;
    private int o;

    private static int compressionLevel(int blockSize) {
        if (blockSize < 64) {
            throw new IllegalArgumentException("blockSize must be >= 64, got " + blockSize);
        }
        if (blockSize > 33554432) {
            throw new IllegalArgumentException("blockSize must be <= 33554432, got " + blockSize);
        }
        int compressionLevel = 32 - Integer.numberOfLeadingZeros(blockSize - 1);
        assert (1 << compressionLevel >= blockSize);
        if (!($assertionsDisabled || blockSize * 2 > 1 << compressionLevel)) {
            throw new AssertionError();
        }
        compressionLevel = Math.max(0, compressionLevel - 10);
        assert (compressionLevel >= 0 && compressionLevel <= 15);
        return compressionLevel;
    }

    public LZ4BlockOutputStream(OutputStream out, int blockSize, LZ4Compressor compressor, Checksum checksum, boolean syncFlush) {
        super(out);
        this.blockSize = blockSize;
        this.compressor = compressor;
        this.checksum = checksum;
        this.compressionLevel = LZ4BlockOutputStream.compressionLevel(blockSize);
        this.buffer = new byte[blockSize];
        int compressedBlockSize = HEADER_LENGTH + compressor.maxCompressedLength(blockSize);
        this.compressedBuffer = new byte[compressedBlockSize];
        this.syncFlush = syncFlush;
        this.o = 0;
        this.finished = false;
        System.arraycopy(MAGIC, 0, this.compressedBuffer, 0, MAGIC_LENGTH);
    }

    public LZ4BlockOutputStream(OutputStream out, int blockSize, LZ4Compressor compressor) {
        this(out, blockSize, compressor, XXHashFactory.fastestInstance().newStreamingHash32(-1756908916).asChecksum(), false);
    }

    public LZ4BlockOutputStream(OutputStream out, int blockSize) {
        this(out, blockSize, LZ4Factory.fastestInstance().fastCompressor());
    }

    public LZ4BlockOutputStream(OutputStream out) {
        this(out, 65536);
    }

    private void ensureNotFinished() {
        if (this.finished) {
            throw new IllegalStateException("This stream is already closed");
        }
    }

    @Override
    public void write(int b) throws IOException {
        this.ensureNotFinished();
        if (this.o == this.blockSize) {
            this.flushBufferedData();
        }
        this.buffer[this.o++] = (byte)b;
    }

    @Override
    public void write(byte[] b, int off, int len) throws IOException {
        SafeUtils.checkRange(b, off, len);
        this.ensureNotFinished();
        while (this.o + len > this.blockSize) {
            int l = this.blockSize - this.o;
            System.arraycopy(b, off, this.buffer, this.o, this.blockSize - this.o);
            this.o = this.blockSize;
            this.flushBufferedData();
            off+=l;
            len-=l;
        }
        System.arraycopy(b, off, this.buffer, this.o, len);
        this.o+=len;
    }

    @Override
    public void write(byte[] b) throws IOException {
        this.ensureNotFinished();
        this.write(b, 0, b.length);
    }

    @Override
    public void close() throws IOException {
        if (!this.finished) {
            this.finish();
        }
        if (this.out != null) {
            this.out.close();
            this.out = null;
        }
    }

    private void flushBufferedData() throws IOException {
        int compressMethod;
        if (this.o == 0) {
            return;
        }
        this.checksum.reset();
        this.checksum.update(this.buffer, 0, this.o);
        int check = (int)this.checksum.getValue();
        int compressedLength = this.compressor.compress(this.buffer, 0, this.o, this.compressedBuffer, HEADER_LENGTH);
        if (compressedLength >= this.o) {
            compressMethod = 16;
            compressedLength = this.o;
            System.arraycopy(this.buffer, 0, this.compressedBuffer, HEADER_LENGTH, this.o);
        } else {
            compressMethod = 32;
        }
        this.compressedBuffer[LZ4BlockOutputStream.MAGIC_LENGTH] = (byte)(compressMethod | this.compressionLevel);
        LZ4BlockOutputStream.writeIntLE(compressedLength, this.compressedBuffer, MAGIC_LENGTH + 1);
        LZ4BlockOutputStream.writeIntLE(this.o, this.compressedBuffer, MAGIC_LENGTH + 5);
        LZ4BlockOutputStream.writeIntLE(check, this.compressedBuffer, MAGIC_LENGTH + 9);
        assert (MAGIC_LENGTH + 13 == HEADER_LENGTH);
        this.out.write(this.compressedBuffer, 0, HEADER_LENGTH + compressedLength);
        this.o = 0;
    }

    @Override
    public void flush() throws IOException {
        if (this.out != null) {
            if (this.syncFlush) {
                this.flushBufferedData();
            }
            this.out.flush();
        }
    }

    public void finish() throws IOException {
        this.ensureNotFinished();
        this.flushBufferedData();
        this.compressedBuffer[LZ4BlockOutputStream.MAGIC_LENGTH] = (byte)(16 | this.compressionLevel);
        LZ4BlockOutputStream.writeIntLE(0, this.compressedBuffer, MAGIC_LENGTH + 1);
        LZ4BlockOutputStream.writeIntLE(0, this.compressedBuffer, MAGIC_LENGTH + 5);
        LZ4BlockOutputStream.writeIntLE(0, this.compressedBuffer, MAGIC_LENGTH + 9);
        assert (MAGIC_LENGTH + 13 == HEADER_LENGTH);
        this.out.write(this.compressedBuffer, 0, HEADER_LENGTH);
        this.finished = true;
        this.out.flush();
    }

    private static void writeIntLE(int i, byte[] buf, int off) {
        buf[off++] = (byte)i;
        buf[off++] = (byte)(i >>> 8);
        buf[off++] = (byte)(i >>> 16);
        buf[off++] = (byte)(i >>> 24);
    }

    public String toString() {
        return this.getClass().getSimpleName() + "(out=" + this.out + ", blockSize=" + this.blockSize + ", compressor=" + this.compressor + ", checksum=" + this.checksum + ")";
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.ByteBufferUtils;

final class LZ4ByteBufferUtils
extends Enum<LZ4ByteBufferUtils> {
    private static final /* synthetic */ LZ4ByteBufferUtils[] $VALUES;

    public static LZ4ByteBufferUtils[] values() {
        return (LZ4ByteBufferUtils[])$VALUES.clone();
    }

    public static LZ4ByteBufferUtils valueOf(String name) {
        return (LZ4ByteBufferUtils)Enum.valueOf(LZ4ByteBufferUtils.class, name);
    }

    private LZ4ByteBufferUtils() {
        super(string, n);
    }

    static int hash(ByteBuffer buf, int i) {
        return LZ4Utils.hash(ByteBufferUtils.readInt(buf, i));
    }

    static int hash64k(ByteBuffer buf, int i) {
        return LZ4Utils.hash64k(ByteBufferUtils.readInt(buf, i));
    }

    static boolean readIntEquals(ByteBuffer buf, int i, int j) {
        return buf.getInt(i) == buf.getInt(j);
    }

    static void safeIncrementalCopy(ByteBuffer dest, int matchOff, int dOff, int matchLen) {
        for (int i = 0; i < matchLen; ++i) {
            dest.put(dOff + i, dest.get(matchOff + i));
        }
    }

    static void wildIncrementalCopy(ByteBuffer dest, int matchOff, int dOff, int matchCopyEnd) {
        if (dOff - matchOff < 4) {
            for (int i = 0; i < 4; ++i) {
                ByteBufferUtils.writeByte(dest, dOff + i, ByteBufferUtils.readByte(dest, matchOff + i));
            }
            int dec = 0;
            assert (dOff >= matchOff && (dOff+=4) - (matchOff+=4) < 8);
            switch (dOff - matchOff) {
                case 1: {
                    matchOff-=3;
                    break;
                }
                case 2: {
                    matchOff-=2;
                    break;
                }
                case 3: {
                    matchOff-=3;
                    dec = -1;
                    break;
                }
                case 5: {
                    dec = 1;
                    break;
                }
                case 6: {
                    dec = 2;
                    break;
                }
                case 7: {
                    dec = 3;
                    break;
                }
            }
            ByteBufferUtils.writeInt(dest, dOff, ByteBufferUtils.readInt(dest, matchOff));
            dOff+=4;
            matchOff-=dec;
        } else if (dOff - matchOff < 8) {
            ByteBufferUtils.writeLong(dest, dOff, ByteBufferUtils.readLong(dest, matchOff));
            dOff+=dOff - matchOff;
        }
        while (dOff < matchCopyEnd) {
            ByteBufferUtils.writeLong(dest, dOff, ByteBufferUtils.readLong(dest, matchOff));
            dOff+=8;
            matchOff+=8;
        }
    }

    static int commonBytes(ByteBuffer src, int ref, int sOff, int srcLimit) {
        int matchLen = 0;
        while (sOff <= srcLimit - 8) {
            if (ByteBufferUtils.readLong(src, sOff) == ByteBufferUtils.readLong(src, ref)) {
                matchLen+=8;
                ref+=8;
                sOff+=8;
                continue;
            }
            int zeroBits = src.order() == ByteOrder.BIG_ENDIAN ? Long.numberOfLeadingZeros(ByteBufferUtils.readLong(src, sOff) ^ ByteBufferUtils.readLong(src, ref)) : Long.numberOfTrailingZeros(ByteBufferUtils.readLong(src, sOff) ^ ByteBufferUtils.readLong(src, ref));
            return matchLen + (zeroBits >>> 3);
        }
        while (sOff < srcLimit && ByteBufferUtils.readByte(src, ref++) == ByteBufferUtils.readByte(src, sOff++)) {
            ++matchLen;
        }
        return matchLen;
    }

    static int commonBytesBackward(ByteBuffer b, int o1, int o2, int l1, int l2) {
        int count = 0;
        while (o1 > l1 && o2 > l2 && b.get(--o1) == b.get(--o2)) {
            ++count;
        }
        return count;
    }

    static void safeArraycopy(ByteBuffer src, int sOff, ByteBuffer dest, int dOff, int len) {
        for (int i = 0; i < len; ++i) {
            dest.put(dOff + i, src.get(sOff + i));
        }
    }

    static void wildArraycopy(ByteBuffer src, int sOff, ByteBuffer dest, int dOff, int len) {
        assert (src.order().equals(dest.order()));
        try {
            for (int i = 0; i < len; i+=8) {
                dest.putLong(dOff + i, src.getLong(sOff + i));
            }
        }
        catch (IndexOutOfBoundsException e) {
            throw new LZ4Exception("Malformed input at offset " + sOff);
        }
    }

    static int encodeSequence(ByteBuffer src, int anchor, int matchOff, int matchRef, int matchLen, ByteBuffer dest, int dOff, int destEnd) {
        int token;
        int runLen = matchOff - anchor;
        int tokenOff = dOff++;
        if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        if (runLen >= 15) {
            token = -16;
            dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
        } else {
            token = runLen << 4;
        }
        LZ4ByteBufferUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
        dOff+=runLen;
        int matchDec = matchOff - matchRef;
        dest.put(dOff++, (byte)matchDec);
        dest.put(dOff++, (byte)(matchDec >>> 8));
        if (dOff + 6 + ((matchLen-=4) >>> 8) > destEnd) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        if (matchLen >= 15) {
            token|=15;
            dOff = LZ4ByteBufferUtils.writeLen(matchLen - 15, dest, dOff);
        } else {
            token|=matchLen;
        }
        dest.put(tokenOff, (byte)token);
        return dOff;
    }

    static int lastLiterals(ByteBuffer src, int sOff, int srcLen, ByteBuffer dest, int dOff, int destEnd) {
        int runLen = srcLen;
        if (dOff + runLen + 1 + (runLen + 255 - 15) / 255 > destEnd) {
            throw new LZ4Exception();
        }
        if (runLen >= 15) {
            dest.put(dOff++, -16);
            dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
        } else {
            dest.put(dOff++, (byte)(runLen << 4));
        }
        LZ4ByteBufferUtils.safeArraycopy(src, sOff, dest, dOff, runLen);
        return dOff+=runLen;
    }

    static int writeLen(int len, ByteBuffer dest, int dOff) {
        while (len >= 255) {
            dest.put(dOff++, -1);
            len-=255;
        }
        dest.put(dOff++, (byte)len);
        return dOff;
    }

    static void copyTo(Match m1, Match m2) {
        m2.len = m1.len;
        m2.start = m1.start;
        m2.ref = m1.ref;
    }

    static {
        $VALUES = new LZ4ByteBufferUtils[0];
    }

    static class Match {
        int start;
        int ref;
        int len;

        Match() {
        }

        void fix(int correction) {
            this.start+=correction;
            this.ref+=correction;
            this.len-=correction;
        }

        int end() {
            return this.start + this.len;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4Utils;

public abstract class LZ4Compressor {
    public final int maxCompressedLength(int length) {
        return LZ4Utils.maxCompressedLength(length);
    }

    public abstract int compress(byte[] var1, int var2, int var3, byte[] var4, int var5, int var6);

    public abstract int compress(ByteBuffer var1, int var2, int var3, ByteBuffer var4, int var5, int var6);

    public final int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff) {
        return this.compress(src, srcOff, srcLen, dest, destOff, dest.length - destOff);
    }

    public final int compress(byte[] src, byte[] dest) {
        return this.compress(src, 0, src.length, dest, 0);
    }

    public final byte[] compress(byte[] src, int srcOff, int srcLen) {
        int maxCompressedLength = this.maxCompressedLength(srcLen);
        byte[] compressed = new byte[maxCompressedLength];
        int compressedLength = this.compress(src, srcOff, srcLen, compressed, 0);
        return Arrays.copyOf(compressed, compressedLength);
    }

    public final byte[] compress(byte[] src) {
        return this.compress(src, 0, src.length);
    }

    public final void compress(ByteBuffer src, ByteBuffer dest) {
        int cpLen = this.compress(src, src.position(), src.remaining(), dest, dest.position(), dest.remaining());
        src.position(src.limit());
        dest.position(dest.position() + cpLen);
    }

    public String toString() {
        return this.getClass().getSimpleName();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

final class LZ4Constants
extends Enum<LZ4Constants> {
    static final int DEFAULT_COMPRESSION_LEVEL = 9;
    static final int MAX_COMPRESSION_LEVEL = 17;
    static final int MEMORY_USAGE = 14;
    static final int NOT_COMPRESSIBLE_DETECTION_LEVEL = 6;
    static final int MIN_MATCH = 4;
    static final int HASH_LOG = 12;
    static final int HASH_TABLE_SIZE = 4096;
    static final int SKIP_STRENGTH;
    static final int COPY_LENGTH = 8;
    static final int LAST_LITERALS = 5;
    static final int MF_LIMIT = 12;
    static final int MIN_LENGTH = 13;
    static final int MAX_DISTANCE = 65536;
    static final int ML_BITS = 4;
    static final int ML_MASK = 15;
    static final int RUN_BITS = 4;
    static final int RUN_MASK = 15;
    static final int LZ4_64K_LIMIT = 65547;
    static final int HASH_LOG_64K = 13;
    static final int HASH_TABLE_SIZE_64K = 8192;
    static final int HASH_LOG_HC = 15;
    static final int HASH_TABLE_SIZE_HC = 32768;
    static final int OPTIMAL_ML = 18;
    private static final /* synthetic */ LZ4Constants[] $VALUES;

    public static LZ4Constants[] values() {
        return (LZ4Constants[])$VALUES.clone();
    }

    public static LZ4Constants valueOf(String name) {
        return (LZ4Constants)Enum.valueOf(LZ4Constants.class, name);
    }

    private LZ4Constants() {
        super(string, n);
    }

    static {
        $VALUES = new LZ4Constants[0];
        SKIP_STRENGTH = Math.max(6, 2);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

@Deprecated
public interface LZ4Decompressor {
    public int decompress(byte[] var1, int var2, byte[] var3, int var4, int var5);
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

public class LZ4Exception
extends RuntimeException {
    private static final long serialVersionUID = 1;

    public LZ4Exception(String msg, Throwable t) {
        super(msg, t);
    }

    public LZ4Exception(String msg) {
        super(msg);
    }

    public LZ4Exception() {
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.io.PrintStream;
import java.util.Arrays;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Decompressor;
import net.jpountz.lz4.LZ4FastDecompressor;
import net.jpountz.lz4.LZ4SafeDecompressor;
import net.jpountz.lz4.LZ4UnknownSizeDecompressor;
import net.jpountz.util.Native;
import net.jpountz.util.Utils;

public final class LZ4Factory {
    private static LZ4Factory NATIVE_INSTANCE;
    private static LZ4Factory JAVA_UNSAFE_INSTANCE;
    private static LZ4Factory JAVA_SAFE_INSTANCE;
    private final String impl;
    private final LZ4Compressor fastCompressor;
    private final LZ4Compressor highCompressor;
    private final LZ4FastDecompressor fastDecompressor;
    private final LZ4SafeDecompressor safeDecompressor;
    private final LZ4Compressor[] highCompressors = new LZ4Compressor[18];

    private static LZ4Factory instance(String impl) {
        try {
            return new LZ4Factory(impl);
        }
        catch (Exception e) {
            throw new AssertionError(e);
        }
    }

    public static synchronized LZ4Factory nativeInstance() {
        if (NATIVE_INSTANCE == null) {
            NATIVE_INSTANCE = LZ4Factory.instance("JNI");
        }
        return NATIVE_INSTANCE;
    }

    public static synchronized LZ4Factory safeInstance() {
        if (JAVA_SAFE_INSTANCE == null) {
            JAVA_SAFE_INSTANCE = LZ4Factory.instance("JavaSafe");
        }
        return JAVA_SAFE_INSTANCE;
    }

    public static synchronized LZ4Factory unsafeInstance() {
        if (JAVA_UNSAFE_INSTANCE == null) {
            JAVA_UNSAFE_INSTANCE = LZ4Factory.instance("JavaUnsafe");
        }
        return JAVA_UNSAFE_INSTANCE;
    }

    public static LZ4Factory fastestJavaInstance() {
        if (Utils.isUnalignedAccessAllowed()) {
            try {
                return LZ4Factory.unsafeInstance();
            }
            catch (Throwable t) {
                return LZ4Factory.safeInstance();
            }
        }
        return LZ4Factory.safeInstance();
    }

    public static LZ4Factory fastestInstance() {
        if (Native.isLoaded() || Native.class.getClassLoader() == ClassLoader.getSystemClassLoader()) {
            try {
                return LZ4Factory.nativeInstance();
            }
            catch (Throwable t) {
                return LZ4Factory.fastestJavaInstance();
            }
        }
        return LZ4Factory.fastestJavaInstance();
    }

    private static <T> T classInstance(String cls) throws NoSuchFieldException, SecurityException, ClassNotFoundException, IllegalArgumentException, IllegalAccessException {
        Class c = LZ4Factory.class.getClassLoader().loadClass(cls);
        Field f = c.getField("INSTANCE");
        return (T)f.get(null);
    }

    private LZ4Factory(String impl) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException {
        this.impl = impl;
        this.fastCompressor = (LZ4Compressor)LZ4Factory.classInstance("net.jpountz.lz4.LZ4" + impl + "Compressor");
        this.highCompressor = (LZ4Compressor)LZ4Factory.classInstance("net.jpountz.lz4.LZ4HC" + impl + "Compressor");
        this.fastDecompressor = (LZ4FastDecompressor)LZ4Factory.classInstance("net.jpountz.lz4.LZ4" + impl + "FastDecompressor");
        this.safeDecompressor = (LZ4SafeDecompressor)LZ4Factory.classInstance("net.jpountz.lz4.LZ4" + impl + "SafeDecompressor");
        Constructor highConstructor = this.highCompressor.getClass().getDeclaredConstructor(Integer.TYPE);
        this.highCompressors[9] = this.highCompressor;
        for (int level = 1; level <= 17; ++level) {
            if (level == 9) continue;
            this.highCompressors[level] = (LZ4Compressor)highConstructor.newInstance(level);
        }
        byte[] original = new byte[]{97, 98, 99, 100, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106};
        for (LZ4Compressor compressor : Arrays.asList(this.fastCompressor, this.highCompressor)) {
            int maxCompressedLength = compressor.maxCompressedLength(original.length);
            byte[] compressed = new byte[maxCompressedLength];
            int compressedLength = compressor.compress(original, 0, original.length, compressed, 0, maxCompressedLength);
            byte[] restored = new byte[original.length];
            this.fastDecompressor.decompress(compressed, 0, restored, 0, original.length);
            if (!Arrays.equals(original, restored)) {
                throw new AssertionError();
            }
            Arrays.fill(restored, 0);
            int decompressedLength = this.safeDecompressor.decompress(compressed, 0, compressedLength, restored, 0);
            if (decompressedLength == original.length && Arrays.equals(original, restored)) continue;
            throw new AssertionError();
        }
    }

    public LZ4Compressor fastCompressor() {
        return this.fastCompressor;
    }

    public LZ4Compressor highCompressor() {
        return this.highCompressor;
    }

    public LZ4Compressor highCompressor(int compressionLevel) {
        if (compressionLevel > 17) {
            compressionLevel = 17;
        } else if (compressionLevel < 1) {
            compressionLevel = 9;
        }
        return this.highCompressors[compressionLevel];
    }

    public LZ4FastDecompressor fastDecompressor() {
        return this.fastDecompressor;
    }

    public LZ4SafeDecompressor safeDecompressor() {
        return this.safeDecompressor;
    }

    public LZ4UnknownSizeDecompressor unknownSizeDecompressor() {
        return this.safeDecompressor();
    }

    public LZ4Decompressor decompressor() {
        return this.fastDecompressor();
    }

    public static void main(String[] args) {
        System.out.println("Fastest instance is " + LZ4Factory.fastestInstance());
        System.out.println("Fastest Java instance is " + LZ4Factory.fastestJavaInstance());
    }

    public String toString() {
        return this.getClass().getSimpleName() + ":" + this.impl;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4Decompressor;

public abstract class LZ4FastDecompressor
implements LZ4Decompressor {
    @Override
    public abstract int decompress(byte[] var1, int var2, byte[] var3, int var4, int var5);

    public abstract int decompress(ByteBuffer var1, int var2, ByteBuffer var3, int var4, int var5);

    public final int decompress(byte[] src, byte[] dest, int destLen) {
        return this.decompress(src, 0, dest, 0, destLen);
    }

    public final int decompress(byte[] src, byte[] dest) {
        return this.decompress(src, dest, dest.length);
    }

    public final byte[] decompress(byte[] src, int srcOff, int destLen) {
        byte[] decompressed = new byte[destLen];
        this.decompress(src, srcOff, decompressed, 0, destLen);
        return decompressed;
    }

    public final byte[] decompress(byte[] src, int destLen) {
        return this.decompress(src, 0, destLen);
    }

    public final void decompress(ByteBuffer src, ByteBuffer dest) {
        int read = this.decompress(src, src.position(), dest, dest.position(), dest.remaining());
        dest.position(dest.limit());
        src.position(src.position() + read);
    }

    public String toString() {
        return this.getClass().getSimpleName();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4JNI;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4HCJNICompressor
extends LZ4Compressor {
    public static final LZ4HCJNICompressor INSTANCE = new LZ4HCJNICompressor();
    private static LZ4Compressor SAFE_INSTANCE;
    private final int compressionLevel;

    LZ4HCJNICompressor() {
        this(9);
    }

    LZ4HCJNICompressor(int compressionLevel) {
        this.compressionLevel = compressionLevel;
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, maxDestLen);
        int result = LZ4JNI.LZ4_compressHC(src, null, srcOff, srcLen, dest, null, destOff, maxDestLen, this.compressionLevel);
        if (result <= 0) {
            throw new LZ4Exception();
        }
        return result;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        ByteBufferUtils.checkNotReadOnly(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        Object srcArr = null;
        Object destArr = null;
        ByteBuffer srcBuf = null;
        ByteBuffer destBuf = null;
        if (src.hasArray()) {
            srcArr = src.array();
        } else if (src.isDirect()) {
            srcBuf = src;
        }
        if (dest.hasArray()) {
            destArr = dest.array();
        } else if (dest.isDirect()) {
            destBuf = dest;
        }
        if ((srcArr != null || srcBuf != null) && (destArr != null || destBuf != null)) {
            int result = LZ4JNI.LZ4_compressHC((byte[])srcArr, srcBuf, srcOff, srcLen, (byte[])destArr, destBuf, destOff, maxDestLen, this.compressionLevel);
            if (result <= 0) {
                throw new LZ4Exception();
            }
            return result;
        }
        LZ4Compressor safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = LZ4HCJNICompressor.SAFE_INSTANCE = LZ4Factory.safeInstance().highCompressor(this.compressionLevel);
        }
        return safeInstance.compress(src, srcOff, srcLen, dest, destOff, maxDestLen);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4SafeUtils;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4HCJavaSafeCompressor
extends LZ4Compressor {
    public static final LZ4Compressor INSTANCE = new LZ4HCJavaSafeCompressor();
    private final int maxAttempts;
    final int compressionLevel;

    LZ4HCJavaSafeCompressor() {
        this(9);
    }

    LZ4HCJavaSafeCompressor(int compressionLevel) {
        this.maxAttempts = 1 << compressionLevel - 1;
        this.compressionLevel = compressionLevel;
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, maxDestLen);
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + maxDestLen;
        int mfLimit = srcEnd - 12;
        int matchLimit = srcEnd - 5;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        HashTable ht = new HashTable(srcOff);
        LZ4Utils.Match match0 = new LZ4Utils.Match();
        LZ4Utils.Match match1 = new LZ4Utils.Match();
        LZ4Utils.Match match2 = new LZ4Utils.Match();
        LZ4Utils.Match match3 = new LZ4Utils.Match();
        block0 : while (sOff < mfLimit) {
            if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {
                ++sOff;
                continue;
            }
            LZ4Utils.copyTo(match1, match0);
            block1 : do {
                assert (match1.start >= anchor);
                if (!(match1.end() < mfLimit && ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2))) {
                    dOff = LZ4SafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    continue block0;
                }
                if (match0.start < match1.start && match2.start < match1.start + match0.len) {
                    LZ4Utils.copyTo(match0, match1);
                }
                assert (match2.start > match1.start);
                if (match2.start - match1.start < 3) {
                    LZ4Utils.copyTo(match2, match1);
                    continue;
                }
                do {
                    int correction;
                    if (match2.start - match1.start < 18) {
                        int correction2;
                        int newMatchLen = match1.len;
                        if (newMatchLen > 18) {
                            newMatchLen = 18;
                        }
                        if (match1.start + newMatchLen > match2.end() - 4) {
                            newMatchLen = match2.start - match1.start + match2.len - 4;
                        }
                        if ((correction2 = newMatchLen - (match2.start - match1.start)) > 0) {
                            match2.fix(correction2);
                        }
                    }
                    if (!(match2.start + match2.len < mfLimit && ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3))) {
                        if (match2.start < match1.end()) {
                            match1.len = match2.start - match1.start;
                        }
                        dOff = LZ4SafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                        anchor = sOff = match1.end();
                        dOff = LZ4SafeUtils.encodeSequence(src, anchor, match2.start, match2.ref, match2.len, dest, dOff, destEnd);
                        anchor = sOff = match2.end();
                        continue block0;
                    }
                    if (match3.start < match1.end() + 3) {
                        if (match3.start >= match1.end()) {
                            if (match2.start < match1.end()) {
                                correction = match1.end() - match2.start;
                                match2.fix(correction);
                                if (match2.len < 4) {
                                    LZ4Utils.copyTo(match3, match2);
                                }
                            }
                            dOff = LZ4SafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                            anchor = sOff = match1.end();
                            LZ4Utils.copyTo(match3, match1);
                            LZ4Utils.copyTo(match2, match0);
                            continue block1;
                        }
                        LZ4Utils.copyTo(match3, match2);
                        continue;
                    }
                    if (match2.start < match1.end()) {
                        if (match2.start - match1.start < 15) {
                            if (match1.len > 18) {
                                match1.len = 18;
                            }
                            if (match1.end() > match2.end() - 4) {
                                match1.len = match2.end() - match1.start - 4;
                            }
                            correction = match1.end() - match2.start;
                            match2.fix(correction);
                        } else {
                            match1.len = match2.start - match1.start;
                        }
                    }
                    dOff = LZ4SafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    LZ4Utils.copyTo(match2, match1);
                    LZ4Utils.copyTo(match3, match2);
                } while (true);
                break;
            } while (true);
        }
        dOff = LZ4SafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        if (src.hasArray() && dest.hasArray()) {
            return this.compress(src.array(), srcOff, srcLen, dest.array(), destOff, maxDestLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + maxDestLen;
        int mfLimit = srcEnd - 12;
        int matchLimit = srcEnd - 5;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        HashTable ht = new HashTable(srcOff);
        LZ4Utils.Match match0 = new LZ4Utils.Match();
        LZ4Utils.Match match1 = new LZ4Utils.Match();
        LZ4Utils.Match match2 = new LZ4Utils.Match();
        LZ4Utils.Match match3 = new LZ4Utils.Match();
        block0 : while (sOff < mfLimit) {
            if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {
                ++sOff;
                continue;
            }
            LZ4Utils.copyTo(match1, match0);
            block1 : do {
                assert (match1.start >= anchor);
                if (!(match1.end() < mfLimit && ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2))) {
                    dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    continue block0;
                }
                if (match0.start < match1.start && match2.start < match1.start + match0.len) {
                    LZ4Utils.copyTo(match0, match1);
                }
                assert (match2.start > match1.start);
                if (match2.start - match1.start < 3) {
                    LZ4Utils.copyTo(match2, match1);
                    continue;
                }
                do {
                    int correction;
                    if (match2.start - match1.start < 18) {
                        int correction2;
                        int newMatchLen = match1.len;
                        if (newMatchLen > 18) {
                            newMatchLen = 18;
                        }
                        if (match1.start + newMatchLen > match2.end() - 4) {
                            newMatchLen = match2.start - match1.start + match2.len - 4;
                        }
                        if ((correction2 = newMatchLen - (match2.start - match1.start)) > 0) {
                            match2.fix(correction2);
                        }
                    }
                    if (!(match2.start + match2.len < mfLimit && ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3))) {
                        if (match2.start < match1.end()) {
                            match1.len = match2.start - match1.start;
                        }
                        dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                        anchor = sOff = match1.end();
                        dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match2.start, match2.ref, match2.len, dest, dOff, destEnd);
                        anchor = sOff = match2.end();
                        continue block0;
                    }
                    if (match3.start < match1.end() + 3) {
                        if (match3.start >= match1.end()) {
                            if (match2.start < match1.end()) {
                                correction = match1.end() - match2.start;
                                match2.fix(correction);
                                if (match2.len < 4) {
                                    LZ4Utils.copyTo(match3, match2);
                                }
                            }
                            dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                            anchor = sOff = match1.end();
                            LZ4Utils.copyTo(match3, match1);
                            LZ4Utils.copyTo(match2, match0);
                            continue block1;
                        }
                        LZ4Utils.copyTo(match3, match2);
                        continue;
                    }
                    if (match2.start < match1.end()) {
                        if (match2.start - match1.start < 15) {
                            if (match1.len > 18) {
                                match1.len = 18;
                            }
                            if (match1.end() > match2.end() - 4) {
                                match1.len = match2.end() - match1.start - 4;
                            }
                            correction = match1.end() - match2.start;
                            match2.fix(correction);
                        } else {
                            match1.len = match2.start - match1.start;
                        }
                    }
                    dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    LZ4Utils.copyTo(match2, match1);
                    LZ4Utils.copyTo(match3, match2);
                } while (true);
                break;
            } while (true);
        }
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    private class HashTable {
        static final int MASK = 65535;
        int nextToUpdate;
        private final int base;
        private final int[] hashTable;
        private final short[] chainTable;

        HashTable(int base) {
            this.base = base;
            this.nextToUpdate = base;
            this.hashTable = new int[32768];
            Arrays.fill(this.hashTable, -1);
            this.chainTable = new short[65536];
        }

        private int hashPointer(byte[] bytes, int off) {
            int v = SafeUtils.readInt(bytes, off);
            return this.hashPointer(v);
        }

        private int hashPointer(ByteBuffer bytes, int off) {
            int v = ByteBufferUtils.readInt(bytes, off);
            return this.hashPointer(v);
        }

        private int hashPointer(int v) {
            int h = LZ4Utils.hashHC(v);
            return this.hashTable[h];
        }

        private int next(int off) {
            return off - (this.chainTable[off & 65535] & 65535);
        }

        private void addHash(byte[] bytes, int off) {
            int v = SafeUtils.readInt(bytes, off);
            this.addHash(v, off);
        }

        private void addHash(ByteBuffer bytes, int off) {
            int v = ByteBufferUtils.readInt(bytes, off);
            this.addHash(v, off);
        }

        private void addHash(int v, int off) {
            int h = LZ4Utils.hashHC(v);
            int delta = off - this.hashTable[h];
            assert (delta > 0);
            if (delta >= 65536) {
                delta = 65535;
            }
            this.chainTable[off & 65535] = (short)delta;
            this.hashTable[h] = off;
        }

        void insert(int off, byte[] bytes) {
            while (this.nextToUpdate < off) {
                this.addHash(bytes, this.nextToUpdate);
                ++this.nextToUpdate;
            }
        }

        void insert(int off, ByteBuffer bytes) {
            while (this.nextToUpdate < off) {
                this.addHash(bytes, this.nextToUpdate);
                ++this.nextToUpdate;
            }
        }

        boolean insertAndFindBestMatch(byte[] buf, int off, int matchLimit, LZ4Utils.Match match) {
            match.start = off;
            match.len = 0;
            int delta = 0;
            int repl = 0;
            this.insert(off, buf);
            int ref = this.hashPointer(buf, off);
            if (ref >= off - 4 && ref <= off && ref >= this.base) {
                if (LZ4SafeUtils.readIntEquals(buf, ref, off)) {
                    delta = off - ref;
                    repl = match.len = 4 + LZ4SafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    match.ref = ref;
                }
                ref = this.next(ref);
            }
            for (int i = 0; i < LZ4HCJavaSafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                int matchLen;
                if (LZ4SafeUtils.readIntEquals(buf, ref, off) && (matchLen = 4 + LZ4SafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit)) > match.len) {
                    match.ref = ref;
                    match.len = matchLen;
                }
                ref = this.next(ref);
            }
            if (repl != 0) {
                int ptr;
                int end = off + repl - 3;
                for (ptr = off; ptr < end - delta; ++ptr) {
                    this.chainTable[ptr & 65535] = (short)delta;
                }
                do {
                    this.chainTable[ptr & 65535] = (short)delta;
                    this.hashTable[LZ4Utils.hashHC((int)SafeUtils.readInt((byte[])buf, (int)ptr))] = ptr++;
                } while (ptr < end);
                this.nextToUpdate = end;
            }
            return match.len != 0;
        }

        boolean insertAndFindWiderMatch(byte[] buf, int off, int startLimit, int matchLimit, int minLen, LZ4Utils.Match match) {
            match.len = minLen;
            this.insert(off, buf);
            int delta = off - startLimit;
            int ref = this.hashPointer(buf, off);
            for (int i = 0; i < LZ4HCJavaSafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                if (LZ4SafeUtils.readIntEquals(buf, ref, off)) {
                    int matchLenForward = 4 + LZ4SafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    int matchLenBackward = LZ4SafeUtils.commonBytesBackward(buf, ref, off, this.base, startLimit);
                    int matchLen = matchLenBackward + matchLenForward;
                    if (matchLen > match.len) {
                        match.len = matchLen;
                        match.ref = ref - matchLenBackward;
                        match.start = off - matchLenBackward;
                    }
                }
                ref = this.next(ref);
            }
            return match.len > minLen;
        }

        boolean insertAndFindBestMatch(ByteBuffer buf, int off, int matchLimit, LZ4Utils.Match match) {
            match.start = off;
            match.len = 0;
            int delta = 0;
            int repl = 0;
            this.insert(off, buf);
            int ref = this.hashPointer(buf, off);
            if (ref >= off - 4 && ref <= off && ref >= this.base) {
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off)) {
                    delta = off - ref;
                    repl = match.len = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    match.ref = ref;
                }
                ref = this.next(ref);
            }
            for (int i = 0; i < LZ4HCJavaSafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                int matchLen;
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off) && (matchLen = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit)) > match.len) {
                    match.ref = ref;
                    match.len = matchLen;
                }
                ref = this.next(ref);
            }
            if (repl != 0) {
                int ptr;
                int end = off + repl - 3;
                for (ptr = off; ptr < end - delta; ++ptr) {
                    this.chainTable[ptr & 65535] = (short)delta;
                }
                do {
                    this.chainTable[ptr & 65535] = (short)delta;
                    this.hashTable[LZ4Utils.hashHC((int)ByteBufferUtils.readInt((ByteBuffer)buf, (int)ptr))] = ptr++;
                } while (ptr < end);
                this.nextToUpdate = end;
            }
            return match.len != 0;
        }

        boolean insertAndFindWiderMatch(ByteBuffer buf, int off, int startLimit, int matchLimit, int minLen, LZ4Utils.Match match) {
            match.len = minLen;
            this.insert(off, buf);
            int delta = off - startLimit;
            int ref = this.hashPointer(buf, off);
            for (int i = 0; i < LZ4HCJavaSafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off)) {
                    int matchLenForward = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    int matchLenBackward = LZ4ByteBufferUtils.commonBytesBackward(buf, ref, off, this.base, startLimit);
                    int matchLen = matchLenBackward + matchLenForward;
                    if (matchLen > match.len) {
                        match.len = matchLen;
                        match.ref = ref - matchLenBackward;
                        match.start = off - matchLenBackward;
                    }
                }
                ref = this.next(ref);
            }
            return match.len > minLen;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4UnsafeUtils;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;

final class LZ4HCJavaUnsafeCompressor
extends LZ4Compressor {
    public static final LZ4Compressor INSTANCE = new LZ4HCJavaUnsafeCompressor();
    private final int maxAttempts;
    final int compressionLevel;

    LZ4HCJavaUnsafeCompressor() {
        this(9);
    }

    LZ4HCJavaUnsafeCompressor(int compressionLevel) {
        this.maxAttempts = 1 << compressionLevel - 1;
        this.compressionLevel = compressionLevel;
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        UnsafeUtils.checkRange(src, srcOff, srcLen);
        UnsafeUtils.checkRange(dest, destOff, maxDestLen);
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + maxDestLen;
        int mfLimit = srcEnd - 12;
        int matchLimit = srcEnd - 5;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        HashTable ht = new HashTable(srcOff);
        LZ4Utils.Match match0 = new LZ4Utils.Match();
        LZ4Utils.Match match1 = new LZ4Utils.Match();
        LZ4Utils.Match match2 = new LZ4Utils.Match();
        LZ4Utils.Match match3 = new LZ4Utils.Match();
        block0 : while (sOff < mfLimit) {
            if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {
                ++sOff;
                continue;
            }
            LZ4Utils.copyTo(match1, match0);
            block1 : do {
                assert (match1.start >= anchor);
                if (!(match1.end() < mfLimit && ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2))) {
                    dOff = LZ4UnsafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    continue block0;
                }
                if (match0.start < match1.start && match2.start < match1.start + match0.len) {
                    LZ4Utils.copyTo(match0, match1);
                }
                assert (match2.start > match1.start);
                if (match2.start - match1.start < 3) {
                    LZ4Utils.copyTo(match2, match1);
                    continue;
                }
                do {
                    int correction;
                    if (match2.start - match1.start < 18) {
                        int correction2;
                        int newMatchLen = match1.len;
                        if (newMatchLen > 18) {
                            newMatchLen = 18;
                        }
                        if (match1.start + newMatchLen > match2.end() - 4) {
                            newMatchLen = match2.start - match1.start + match2.len - 4;
                        }
                        if ((correction2 = newMatchLen - (match2.start - match1.start)) > 0) {
                            match2.fix(correction2);
                        }
                    }
                    if (!(match2.start + match2.len < mfLimit && ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3))) {
                        if (match2.start < match1.end()) {
                            match1.len = match2.start - match1.start;
                        }
                        dOff = LZ4UnsafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                        anchor = sOff = match1.end();
                        dOff = LZ4UnsafeUtils.encodeSequence(src, anchor, match2.start, match2.ref, match2.len, dest, dOff, destEnd);
                        anchor = sOff = match2.end();
                        continue block0;
                    }
                    if (match3.start < match1.end() + 3) {
                        if (match3.start >= match1.end()) {
                            if (match2.start < match1.end()) {
                                correction = match1.end() - match2.start;
                                match2.fix(correction);
                                if (match2.len < 4) {
                                    LZ4Utils.copyTo(match3, match2);
                                }
                            }
                            dOff = LZ4UnsafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                            anchor = sOff = match1.end();
                            LZ4Utils.copyTo(match3, match1);
                            LZ4Utils.copyTo(match2, match0);
                            continue block1;
                        }
                        LZ4Utils.copyTo(match3, match2);
                        continue;
                    }
                    if (match2.start < match1.end()) {
                        if (match2.start - match1.start < 15) {
                            if (match1.len > 18) {
                                match1.len = 18;
                            }
                            if (match1.end() > match2.end() - 4) {
                                match1.len = match2.end() - match1.start - 4;
                            }
                            correction = match1.end() - match2.start;
                            match2.fix(correction);
                        } else {
                            match1.len = match2.start - match1.start;
                        }
                    }
                    dOff = LZ4UnsafeUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    LZ4Utils.copyTo(match2, match1);
                    LZ4Utils.copyTo(match3, match2);
                } while (true);
                break;
            } while (true);
        }
        dOff = LZ4UnsafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        if (src.hasArray() && dest.hasArray()) {
            return this.compress(src.array(), srcOff, srcLen, dest.array(), destOff, maxDestLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + maxDestLen;
        int mfLimit = srcEnd - 12;
        int matchLimit = srcEnd - 5;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        HashTable ht = new HashTable(srcOff);
        LZ4Utils.Match match0 = new LZ4Utils.Match();
        LZ4Utils.Match match1 = new LZ4Utils.Match();
        LZ4Utils.Match match2 = new LZ4Utils.Match();
        LZ4Utils.Match match3 = new LZ4Utils.Match();
        block0 : while (sOff < mfLimit) {
            if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {
                ++sOff;
                continue;
            }
            LZ4Utils.copyTo(match1, match0);
            block1 : do {
                assert (match1.start >= anchor);
                if (!(match1.end() < mfLimit && ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2))) {
                    dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    continue block0;
                }
                if (match0.start < match1.start && match2.start < match1.start + match0.len) {
                    LZ4Utils.copyTo(match0, match1);
                }
                assert (match2.start > match1.start);
                if (match2.start - match1.start < 3) {
                    LZ4Utils.copyTo(match2, match1);
                    continue;
                }
                do {
                    int correction;
                    if (match2.start - match1.start < 18) {
                        int correction2;
                        int newMatchLen = match1.len;
                        if (newMatchLen > 18) {
                            newMatchLen = 18;
                        }
                        if (match1.start + newMatchLen > match2.end() - 4) {
                            newMatchLen = match2.start - match1.start + match2.len - 4;
                        }
                        if ((correction2 = newMatchLen - (match2.start - match1.start)) > 0) {
                            match2.fix(correction2);
                        }
                    }
                    if (!(match2.start + match2.len < mfLimit && ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3))) {
                        if (match2.start < match1.end()) {
                            match1.len = match2.start - match1.start;
                        }
                        dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                        anchor = sOff = match1.end();
                        dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match2.start, match2.ref, match2.len, dest, dOff, destEnd);
                        anchor = sOff = match2.end();
                        continue block0;
                    }
                    if (match3.start < match1.end() + 3) {
                        if (match3.start >= match1.end()) {
                            if (match2.start < match1.end()) {
                                correction = match1.end() - match2.start;
                                match2.fix(correction);
                                if (match2.len < 4) {
                                    LZ4Utils.copyTo(match3, match2);
                                }
                            }
                            dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                            anchor = sOff = match1.end();
                            LZ4Utils.copyTo(match3, match1);
                            LZ4Utils.copyTo(match2, match0);
                            continue block1;
                        }
                        LZ4Utils.copyTo(match3, match2);
                        continue;
                    }
                    if (match2.start < match1.end()) {
                        if (match2.start - match1.start < 15) {
                            if (match1.len > 18) {
                                match1.len = 18;
                            }
                            if (match1.end() > match2.end() - 4) {
                                match1.len = match2.end() - match1.start - 4;
                            }
                            correction = match1.end() - match2.start;
                            match2.fix(correction);
                        } else {
                            match1.len = match2.start - match1.start;
                        }
                    }
                    dOff = LZ4ByteBufferUtils.encodeSequence(src, anchor, match1.start, match1.ref, match1.len, dest, dOff, destEnd);
                    anchor = sOff = match1.end();
                    LZ4Utils.copyTo(match2, match1);
                    LZ4Utils.copyTo(match3, match2);
                } while (true);
                break;
            } while (true);
        }
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    private class HashTable {
        static final int MASK = 65535;
        int nextToUpdate;
        private final int base;
        private final int[] hashTable;
        private final short[] chainTable;

        HashTable(int base) {
            this.base = base;
            this.nextToUpdate = base;
            this.hashTable = new int[32768];
            Arrays.fill(this.hashTable, -1);
            this.chainTable = new short[65536];
        }

        private int hashPointer(byte[] bytes, int off) {
            int v = UnsafeUtils.readInt(bytes, off);
            return this.hashPointer(v);
        }

        private int hashPointer(ByteBuffer bytes, int off) {
            int v = ByteBufferUtils.readInt(bytes, off);
            return this.hashPointer(v);
        }

        private int hashPointer(int v) {
            int h = LZ4Utils.hashHC(v);
            return this.hashTable[h];
        }

        private int next(int off) {
            return off - (this.chainTable[off & 65535] & 65535);
        }

        private void addHash(byte[] bytes, int off) {
            int v = UnsafeUtils.readInt(bytes, off);
            this.addHash(v, off);
        }

        private void addHash(ByteBuffer bytes, int off) {
            int v = ByteBufferUtils.readInt(bytes, off);
            this.addHash(v, off);
        }

        private void addHash(int v, int off) {
            int h = LZ4Utils.hashHC(v);
            int delta = off - this.hashTable[h];
            assert (delta > 0);
            if (delta >= 65536) {
                delta = 65535;
            }
            this.chainTable[off & 65535] = (short)delta;
            this.hashTable[h] = off;
        }

        void insert(int off, byte[] bytes) {
            while (this.nextToUpdate < off) {
                this.addHash(bytes, this.nextToUpdate);
                ++this.nextToUpdate;
            }
        }

        void insert(int off, ByteBuffer bytes) {
            while (this.nextToUpdate < off) {
                this.addHash(bytes, this.nextToUpdate);
                ++this.nextToUpdate;
            }
        }

        boolean insertAndFindBestMatch(byte[] buf, int off, int matchLimit, LZ4Utils.Match match) {
            match.start = off;
            match.len = 0;
            int delta = 0;
            int repl = 0;
            this.insert(off, buf);
            int ref = this.hashPointer(buf, off);
            if (ref >= off - 4 && ref <= off && ref >= this.base) {
                if (LZ4UnsafeUtils.readIntEquals(buf, ref, off)) {
                    delta = off - ref;
                    repl = match.len = 4 + LZ4UnsafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    match.ref = ref;
                }
                ref = this.next(ref);
            }
            for (int i = 0; i < LZ4HCJavaUnsafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                int matchLen;
                if (LZ4UnsafeUtils.readIntEquals(buf, ref, off) && (matchLen = 4 + LZ4UnsafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit)) > match.len) {
                    match.ref = ref;
                    match.len = matchLen;
                }
                ref = this.next(ref);
            }
            if (repl != 0) {
                int ptr;
                int end = off + repl - 3;
                for (ptr = off; ptr < end - delta; ++ptr) {
                    this.chainTable[ptr & 65535] = (short)delta;
                }
                do {
                    this.chainTable[ptr & 65535] = (short)delta;
                    this.hashTable[LZ4Utils.hashHC((int)UnsafeUtils.readInt((byte[])buf, (int)ptr))] = ptr++;
                } while (ptr < end);
                this.nextToUpdate = end;
            }
            return match.len != 0;
        }

        boolean insertAndFindWiderMatch(byte[] buf, int off, int startLimit, int matchLimit, int minLen, LZ4Utils.Match match) {
            match.len = minLen;
            this.insert(off, buf);
            int delta = off - startLimit;
            int ref = this.hashPointer(buf, off);
            for (int i = 0; i < LZ4HCJavaUnsafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                if (LZ4UnsafeUtils.readIntEquals(buf, ref, off)) {
                    int matchLenForward = 4 + LZ4UnsafeUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    int matchLenBackward = LZ4UnsafeUtils.commonBytesBackward(buf, ref, off, this.base, startLimit);
                    int matchLen = matchLenBackward + matchLenForward;
                    if (matchLen > match.len) {
                        match.len = matchLen;
                        match.ref = ref - matchLenBackward;
                        match.start = off - matchLenBackward;
                    }
                }
                ref = this.next(ref);
            }
            return match.len > minLen;
        }

        boolean insertAndFindBestMatch(ByteBuffer buf, int off, int matchLimit, LZ4Utils.Match match) {
            match.start = off;
            match.len = 0;
            int delta = 0;
            int repl = 0;
            this.insert(off, buf);
            int ref = this.hashPointer(buf, off);
            if (ref >= off - 4 && ref <= off && ref >= this.base) {
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off)) {
                    delta = off - ref;
                    repl = match.len = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    match.ref = ref;
                }
                ref = this.next(ref);
            }
            for (int i = 0; i < LZ4HCJavaUnsafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                int matchLen;
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off) && (matchLen = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit)) > match.len) {
                    match.ref = ref;
                    match.len = matchLen;
                }
                ref = this.next(ref);
            }
            if (repl != 0) {
                int ptr;
                int end = off + repl - 3;
                for (ptr = off; ptr < end - delta; ++ptr) {
                    this.chainTable[ptr & 65535] = (short)delta;
                }
                do {
                    this.chainTable[ptr & 65535] = (short)delta;
                    this.hashTable[LZ4Utils.hashHC((int)ByteBufferUtils.readInt((ByteBuffer)buf, (int)ptr))] = ptr++;
                } while (ptr < end);
                this.nextToUpdate = end;
            }
            return match.len != 0;
        }

        boolean insertAndFindWiderMatch(ByteBuffer buf, int off, int startLimit, int matchLimit, int minLen, LZ4Utils.Match match) {
            match.len = minLen;
            this.insert(off, buf);
            int delta = off - startLimit;
            int ref = this.hashPointer(buf, off);
            for (int i = 0; i < LZ4HCJavaUnsafeCompressor.this.maxAttempts && ref >= Math.max(this.base, off - 65536 + 1) && ref <= off; ++i) {
                if (LZ4ByteBufferUtils.readIntEquals(buf, ref, off)) {
                    int matchLenForward = 4 + LZ4ByteBufferUtils.commonBytes(buf, ref + 4, off + 4, matchLimit);
                    int matchLenBackward = LZ4ByteBufferUtils.commonBytesBackward(buf, ref, off, this.base, startLimit);
                    int matchLen = matchLenBackward + matchLenForward;
                    if (matchLen > match.len) {
                        match.len = matchLen;
                        match.ref = ref - matchLenBackward;
                        match.start = off - matchLenBackward;
                    }
                }
                ref = this.next(ref);
            }
            return match.len > minLen;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.util.Native;

final class LZ4JNI
extends Enum<LZ4JNI> {
    private static final /* synthetic */ LZ4JNI[] $VALUES;

    public static LZ4JNI[] values() {
        return (LZ4JNI[])$VALUES.clone();
    }

    public static LZ4JNI valueOf(String name) {
        return (LZ4JNI)Enum.valueOf(LZ4JNI.class, name);
    }

    private LZ4JNI() {
        super(string, n);
    }

    static native void init();

    static native int LZ4_compress_limitedOutput(byte[] var0, ByteBuffer var1, int var2, int var3, byte[] var4, ByteBuffer var5, int var6, int var7);

    static native int LZ4_compressHC(byte[] var0, ByteBuffer var1, int var2, int var3, byte[] var4, ByteBuffer var5, int var6, int var7, int var8);

    static native int LZ4_decompress_fast(byte[] var0, ByteBuffer var1, int var2, byte[] var3, ByteBuffer var4, int var5, int var6);

    static native int LZ4_decompress_safe(byte[] var0, ByteBuffer var1, int var2, int var3, byte[] var4, ByteBuffer var5, int var6, int var7);

    static native int LZ4_compressBound(int var0);

    static {
        $VALUES = new LZ4JNI[0];
        Native.load();
        LZ4JNI.init();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4JNI;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JNICompressor
extends LZ4Compressor {
    public static final LZ4Compressor INSTANCE = new LZ4JNICompressor();
    private static LZ4Compressor SAFE_INSTANCE;

    LZ4JNICompressor() {
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, maxDestLen);
        int result = LZ4JNI.LZ4_compress_limitedOutput(src, null, srcOff, srcLen, dest, null, destOff, maxDestLen);
        if (result <= 0) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        return result;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        ByteBufferUtils.checkNotReadOnly(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        Object srcArr = null;
        Object destArr = null;
        ByteBuffer srcBuf = null;
        ByteBuffer destBuf = null;
        if (src.hasArray()) {
            srcArr = src.array();
        } else if (src.isDirect()) {
            srcBuf = src;
        }
        if (dest.hasArray()) {
            destArr = dest.array();
        } else if (dest.isDirect()) {
            destBuf = dest;
        }
        if ((srcArr != null || srcBuf != null) && (destArr != null || destBuf != null)) {
            int result = LZ4JNI.LZ4_compress_limitedOutput((byte[])srcArr, srcBuf, srcOff, srcLen, (byte[])destArr, destBuf, destOff, maxDestLen);
            if (result <= 0) {
                throw new LZ4Exception("maxDestLen is too small");
            }
            return result;
        }
        LZ4Compressor safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = LZ4JNICompressor.SAFE_INSTANCE = LZ4Factory.safeInstance().fastCompressor();
        }
        return safeInstance.compress(src, srcOff, srcLen, dest, destOff, maxDestLen);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4FastDecompressor;
import net.jpountz.lz4.LZ4JNI;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JNIFastDecompressor
extends LZ4FastDecompressor {
    public static final LZ4JNIFastDecompressor INSTANCE = new LZ4JNIFastDecompressor();
    private static LZ4FastDecompressor SAFE_INSTANCE;

    LZ4JNIFastDecompressor() {
    }

    @Override
    public final int decompress(byte[] src, int srcOff, byte[] dest, int destOff, int destLen) {
        SafeUtils.checkRange(src, srcOff);
        SafeUtils.checkRange(dest, destOff, destLen);
        int result = LZ4JNI.LZ4_decompress_fast(src, null, srcOff, dest, null, destOff, destLen);
        if (result < 0) {
            throw new LZ4Exception("Error decoding offset " + (srcOff - result) + " of input buffer");
        }
        return result;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, ByteBuffer dest, int destOff, int destLen) {
        ByteBufferUtils.checkNotReadOnly(dest);
        ByteBufferUtils.checkRange(src, srcOff);
        ByteBufferUtils.checkRange(dest, destOff, destLen);
        Object srcArr = null;
        Object destArr = null;
        ByteBuffer srcBuf = null;
        ByteBuffer destBuf = null;
        if (src.hasArray()) {
            srcArr = src.array();
        } else if (src.isDirect()) {
            srcBuf = src;
        }
        if (dest.hasArray()) {
            destArr = dest.array();
        } else if (dest.isDirect()) {
            destBuf = dest;
        }
        if ((srcArr != null || srcBuf != null) && (destArr != null || destBuf != null)) {
            int result = LZ4JNI.LZ4_decompress_fast((byte[])srcArr, srcBuf, srcOff, (byte[])destArr, destBuf, destOff, destLen);
            if (result < 0) {
                throw new LZ4Exception("Error decoding offset " + (srcOff - result) + " of input buffer");
            }
            return result;
        }
        LZ4FastDecompressor safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = LZ4JNIFastDecompressor.SAFE_INSTANCE = LZ4Factory.safeInstance().fastDecompressor();
        }
        return safeInstance.decompress(src, srcOff, dest, destOff, destLen);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4JNI;
import net.jpountz.lz4.LZ4SafeDecompressor;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JNISafeDecompressor
extends LZ4SafeDecompressor {
    public static final LZ4JNISafeDecompressor INSTANCE = new LZ4JNISafeDecompressor();
    private static LZ4SafeDecompressor SAFE_INSTANCE;

    LZ4JNISafeDecompressor() {
    }

    @Override
    public final int decompress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, maxDestLen);
        int result = LZ4JNI.LZ4_decompress_safe(src, null, srcOff, srcLen, dest, null, destOff, maxDestLen);
        if (result < 0) {
            throw new LZ4Exception("Error decoding offset " + (srcOff - result) + " of input buffer");
        }
        return result;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        ByteBufferUtils.checkNotReadOnly(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        Object srcArr = null;
        Object destArr = null;
        ByteBuffer srcBuf = null;
        ByteBuffer destBuf = null;
        if (src.hasArray()) {
            srcArr = src.array();
        } else if (src.isDirect()) {
            srcBuf = src;
        }
        if (dest.hasArray()) {
            destArr = dest.array();
        } else if (dest.isDirect()) {
            destBuf = dest;
        }
        if ((srcArr != null || srcBuf != null) && (destArr != null || destBuf != null)) {
            int result = LZ4JNI.LZ4_decompress_safe((byte[])srcArr, srcBuf, srcOff, srcLen, (byte[])destArr, destBuf, destOff, maxDestLen);
            if (result < 0) {
                throw new LZ4Exception("Error decoding offset " + (srcOff - result) + " of input buffer");
            }
            return result;
        }
        LZ4SafeDecompressor safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = LZ4JNISafeDecompressor.SAFE_INSTANCE = LZ4Factory.safeInstance().safeDecompressor();
        }
        return safeInstance.decompress(src, srcOff, srcLen, dest, destOff, maxDestLen);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Constants;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4SafeUtils;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JavaSafeCompressor
extends LZ4Compressor {
    public static final LZ4Compressor INSTANCE = new LZ4JavaSafeCompressor();

    LZ4JavaSafeCompressor() {
    }

    static int compress64k(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int destEnd) {
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        if (srcLen >= 13) {
            short[] hashTable = new short[8192];
            block0 : do {
                int ref;
                int forwardOff = sOff;
                int step = 1;
                int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
                do {
                    sOff = forwardOff;
                    if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                    int h = LZ4Utils.hash64k(SafeUtils.readInt(src, sOff));
                    ref = srcOff + SafeUtils.readShort(hashTable, h);
                    SafeUtils.writeShort(hashTable, h, sOff - srcOff);
                } while (!LZ4SafeUtils.readIntEquals(src, ref, sOff));
                int excess = LZ4SafeUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
                ref-=excess;
                int runLen = (sOff-=excess) - anchor;
                int tokenOff = dOff++;
                if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                if (runLen >= 15) {
                    SafeUtils.writeByte(dest, tokenOff, 240);
                    dOff = LZ4SafeUtils.writeLen(runLen - 15, dest, dOff);
                } else {
                    SafeUtils.writeByte(dest, tokenOff, runLen << 4);
                }
                LZ4SafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
                dOff+=runLen;
                do {
                    SafeUtils.writeShortLE(dest, dOff, (short)(sOff - ref));
                    int matchLen = LZ4SafeUtils.commonBytes(src, ref+=4, sOff+=4, srcLimit);
                    if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                        throw new LZ4Exception("maxDestLen is too small");
                    }
                    sOff+=matchLen;
                    if (matchLen >= 15) {
                        SafeUtils.writeByte(dest, tokenOff, SafeUtils.readByte(dest, tokenOff) | 15);
                        dOff = LZ4SafeUtils.writeLen(matchLen - 15, dest, dOff);
                    } else {
                        SafeUtils.writeByte(dest, tokenOff, SafeUtils.readByte(dest, tokenOff) | matchLen);
                    }
                    if (sOff > mflimit) {
                        anchor = sOff;
                        break block0;
                    }
                    SafeUtils.writeShort(hashTable, LZ4Utils.hash64k(SafeUtils.readInt(src, sOff - 2)), sOff - 2 - srcOff);
                    int h = LZ4Utils.hash64k(SafeUtils.readInt(src, sOff));
                    ref = srcOff + SafeUtils.readShort(hashTable, h);
                    SafeUtils.writeShort(hashTable, h, sOff - srcOff);
                    if (!LZ4SafeUtils.readIntEquals(src, sOff, ref)) break;
                    tokenOff = dOff++;
                    SafeUtils.writeByte(dest, tokenOff, 0);
                } while (true);
                anchor = sOff++;
            } while (true);
        }
        dOff = LZ4SafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, maxDestLen);
        int destEnd = destOff + maxDestLen;
        if (srcLen < 65547) {
            return LZ4JavaSafeCompressor.compress64k(src, srcOff, srcLen, dest, destOff, destEnd);
        }
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        int[] hashTable = new int[4096];
        Arrays.fill(hashTable, anchor);
        block0 : do {
            int back;
            int ref;
            int forwardOff = sOff;
            int step = 1;
            int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
            do {
                sOff = forwardOff;
                if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                int h = LZ4Utils.hash(SafeUtils.readInt(src, sOff));
                ref = SafeUtils.readInt(hashTable, h);
                back = sOff - ref;
                SafeUtils.writeInt(hashTable, h, sOff);
            } while (back >= 65536 || !LZ4SafeUtils.readIntEquals(src, ref, sOff));
            int excess = LZ4SafeUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
            ref-=excess;
            int runLen = (sOff-=excess) - anchor;
            int tokenOff = dOff++;
            if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                throw new LZ4Exception("maxDestLen is too small");
            }
            if (runLen >= 15) {
                SafeUtils.writeByte(dest, tokenOff, 240);
                dOff = LZ4SafeUtils.writeLen(runLen - 15, dest, dOff);
            } else {
                SafeUtils.writeByte(dest, tokenOff, runLen << 4);
            }
            LZ4SafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
            dOff+=runLen;
            do {
                SafeUtils.writeShortLE(dest, dOff, back);
                int matchLen = LZ4SafeUtils.commonBytes(src, ref + 4, sOff+=4, srcLimit);
                if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                sOff+=matchLen;
                if (matchLen >= 15) {
                    SafeUtils.writeByte(dest, tokenOff, SafeUtils.readByte(dest, tokenOff) | 15);
                    dOff = LZ4SafeUtils.writeLen(matchLen - 15, dest, dOff);
                } else {
                    SafeUtils.writeByte(dest, tokenOff, SafeUtils.readByte(dest, tokenOff) | matchLen);
                }
                if (sOff > mflimit) {
                    anchor = sOff;
                    break block0;
                }
                SafeUtils.writeInt(hashTable, LZ4Utils.hash(SafeUtils.readInt(src, sOff - 2)), sOff - 2);
                int h = LZ4Utils.hash(SafeUtils.readInt(src, sOff));
                ref = SafeUtils.readInt(hashTable, h);
                SafeUtils.writeInt(hashTable, h, sOff);
                back = sOff - ref;
                if (back >= 65536) break;
                if (!LZ4SafeUtils.readIntEquals(src, ref, sOff)) break;
                tokenOff = dOff++;
                SafeUtils.writeByte(dest, tokenOff, 0);
            } while (true);
            anchor = sOff++;
        } while (true);
        dOff = LZ4SafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    static int compress64k(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int destEnd) {
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        if (srcLen >= 13) {
            short[] hashTable = new short[8192];
            block0 : do {
                int ref;
                int forwardOff = sOff;
                int step = 1;
                int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
                do {
                    sOff = forwardOff;
                    if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                    int h = LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff));
                    ref = srcOff + SafeUtils.readShort(hashTable, h);
                    SafeUtils.writeShort(hashTable, h, sOff - srcOff);
                } while (!LZ4ByteBufferUtils.readIntEquals(src, ref, sOff));
                int excess = LZ4ByteBufferUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
                ref-=excess;
                int runLen = (sOff-=excess) - anchor;
                int tokenOff = dOff++;
                if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                if (runLen >= 15) {
                    ByteBufferUtils.writeByte(dest, tokenOff, 240);
                    dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
                } else {
                    ByteBufferUtils.writeByte(dest, tokenOff, runLen << 4);
                }
                LZ4ByteBufferUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
                dOff+=runLen;
                do {
                    ByteBufferUtils.writeShortLE(dest, dOff, (short)(sOff - ref));
                    int matchLen = LZ4ByteBufferUtils.commonBytes(src, ref+=4, sOff+=4, srcLimit);
                    if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                        throw new LZ4Exception("maxDestLen is too small");
                    }
                    sOff+=matchLen;
                    if (matchLen >= 15) {
                        ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | 15);
                        dOff = LZ4ByteBufferUtils.writeLen(matchLen - 15, dest, dOff);
                    } else {
                        ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | matchLen);
                    }
                    if (sOff > mflimit) {
                        anchor = sOff;
                        break block0;
                    }
                    SafeUtils.writeShort(hashTable, LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff - 2)), sOff - 2 - srcOff);
                    int h = LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff));
                    ref = srcOff + SafeUtils.readShort(hashTable, h);
                    SafeUtils.writeShort(hashTable, h, sOff - srcOff);
                    if (!LZ4ByteBufferUtils.readIntEquals(src, sOff, ref)) break;
                    tokenOff = dOff++;
                    ByteBufferUtils.writeByte(dest, tokenOff, 0);
                } while (true);
                anchor = sOff++;
            } while (true);
        }
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        if (src.hasArray() && dest.hasArray()) {
            return this.compress(src.array(), srcOff, srcLen, dest.array(), destOff, maxDestLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        int destEnd = destOff + maxDestLen;
        if (srcLen < 65547) {
            return LZ4JavaSafeCompressor.compress64k(src, srcOff, srcLen, dest, destOff, destEnd);
        }
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        int[] hashTable = new int[4096];
        Arrays.fill(hashTable, anchor);
        block0 : do {
            int back;
            int ref;
            int forwardOff = sOff;
            int step = 1;
            int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
            do {
                sOff = forwardOff;
                if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                int h = LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff));
                ref = SafeUtils.readInt(hashTable, h);
                back = sOff - ref;
                SafeUtils.writeInt(hashTable, h, sOff);
            } while (back >= 65536 || !LZ4ByteBufferUtils.readIntEquals(src, ref, sOff));
            int excess = LZ4ByteBufferUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
            ref-=excess;
            int runLen = (sOff-=excess) - anchor;
            int tokenOff = dOff++;
            if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                throw new LZ4Exception("maxDestLen is too small");
            }
            if (runLen >= 15) {
                ByteBufferUtils.writeByte(dest, tokenOff, 240);
                dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
            } else {
                ByteBufferUtils.writeByte(dest, tokenOff, runLen << 4);
            }
            LZ4ByteBufferUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
            dOff+=runLen;
            do {
                ByteBufferUtils.writeShortLE(dest, dOff, back);
                int matchLen = LZ4ByteBufferUtils.commonBytes(src, ref + 4, sOff+=4, srcLimit);
                if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                sOff+=matchLen;
                if (matchLen >= 15) {
                    ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | 15);
                    dOff = LZ4ByteBufferUtils.writeLen(matchLen - 15, dest, dOff);
                } else {
                    ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | matchLen);
                }
                if (sOff > mflimit) {
                    anchor = sOff;
                    break block0;
                }
                SafeUtils.writeInt(hashTable, LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff - 2)), sOff - 2);
                int h = LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff));
                ref = SafeUtils.readInt(hashTable, h);
                SafeUtils.writeInt(hashTable, h, sOff);
                back = sOff - ref;
                if (back >= 65536) break;
                if (!LZ4ByteBufferUtils.readIntEquals(src, ref, sOff)) break;
                tokenOff = dOff++;
                ByteBufferUtils.writeByte(dest, tokenOff, 0);
            } while (true);
            anchor = sOff++;
        } while (true);
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4FastDecompressor;
import net.jpountz.lz4.LZ4SafeUtils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JavaSafeFastDecompressor
extends LZ4FastDecompressor {
    public static final LZ4FastDecompressor INSTANCE = new LZ4JavaSafeFastDecompressor();

    LZ4JavaSafeFastDecompressor() {
    }

    @Override
    public int decompress(byte[] src, int srcOff, byte[] dest, int destOff, int destLen) {
        int literalLen;
        int literalCopyEnd;
        SafeUtils.checkRange(src, srcOff);
        SafeUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (SafeUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Malformed input at " + srcOff);
            }
            return 1;
        }
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = SafeUtils.readByte(src, sOff) & 255;
            ++sOff;
            literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                do {
                    byte by = SafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                } while (true);
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8) {
                if (literalCopyEnd != destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                } else {
                    break;
                }
            }
            LZ4SafeUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = SafeUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                do {
                    byte by = SafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                } while (true);
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4SafeUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4SafeUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        LZ4SafeUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
        dOff = literalCopyEnd;
        return (sOff+=literalLen) - srcOff;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, ByteBuffer dest, int destOff, int destLen) {
        int literalLen;
        int literalCopyEnd;
        if (src.hasArray() && dest.hasArray()) {
            return this.decompress(src.array(), srcOff, dest.array(), destOff, destLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff);
        ByteBufferUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (ByteBufferUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Malformed input at " + srcOff);
            }
            return 1;
        }
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = ByteBufferUtils.readByte(src, sOff) & 255;
            ++sOff;
            literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                do {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                } while (true);
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8) {
                if (literalCopyEnd != destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                } else {
                    break;
                }
            }
            LZ4ByteBufferUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = ByteBufferUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                do {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                } while (true);
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4ByteBufferUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        LZ4ByteBufferUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
        dOff = literalCopyEnd;
        return (sOff+=literalLen) - srcOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4SafeDecompressor;
import net.jpountz.lz4.LZ4SafeUtils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;

final class LZ4JavaSafeSafeDecompressor
extends LZ4SafeDecompressor {
    public static final LZ4SafeDecompressor INSTANCE = new LZ4JavaSafeSafeDecompressor();

    LZ4JavaSafeSafeDecompressor() {
    }

    @Override
    public int decompress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int destLen) {
        int literalCopyEnd;
        SafeUtils.checkRange(src, srcOff, srcLen);
        SafeUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (srcLen != 1 || SafeUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Output buffer too small");
            }
            return 0;
        }
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = SafeUtils.readByte(src, sOff) & 255;
            ++sOff;
            int literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = SafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                }
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8 || sOff + literalLen > srcEnd - 8) {
                if (literalCopyEnd > destEnd) {
                    throw new LZ4Exception();
                }
                if (sOff + literalLen != srcEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4SafeUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
                sOff+=literalLen;
                break;
            }
            LZ4SafeUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = SafeUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = SafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                }
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4SafeUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4SafeUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        dOff = literalCopyEnd;
        return dOff - destOff;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int destLen) {
        int literalCopyEnd;
        if (src.hasArray() && dest.hasArray()) {
            return this.decompress(src.array(), srcOff, srcLen, dest.array(), destOff, destLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (srcLen != 1 || ByteBufferUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Output buffer too small");
            }
            return 0;
        }
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = ByteBufferUtils.readByte(src, sOff) & 255;
            ++sOff;
            int literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                }
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8 || sOff + literalLen > srcEnd - 8) {
                if (literalCopyEnd > destEnd) {
                    throw new LZ4Exception();
                }
                if (sOff + literalLen != srcEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
                sOff+=literalLen;
                break;
            }
            LZ4ByteBufferUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = ByteBufferUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                }
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4ByteBufferUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        dOff = literalCopyEnd;
        return dOff - destOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Constants;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4UnsafeUtils;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;

final class LZ4JavaUnsafeCompressor
extends LZ4Compressor {
    public static final LZ4Compressor INSTANCE = new LZ4JavaUnsafeCompressor();

    LZ4JavaUnsafeCompressor() {
    }

    static int compress64k(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int destEnd) {
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        if (srcLen >= 13) {
            short[] hashTable = new short[8192];
            block0 : do {
                int ref;
                int forwardOff = sOff;
                int step = 1;
                int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
                do {
                    sOff = forwardOff;
                    if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                    int h = LZ4Utils.hash64k(UnsafeUtils.readInt(src, sOff));
                    ref = srcOff + UnsafeUtils.readShort(hashTable, h);
                    UnsafeUtils.writeShort(hashTable, h, sOff - srcOff);
                } while (!LZ4UnsafeUtils.readIntEquals(src, ref, sOff));
                int excess = LZ4UnsafeUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
                ref-=excess;
                int runLen = (sOff-=excess) - anchor;
                int tokenOff = dOff++;
                if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                if (runLen >= 15) {
                    UnsafeUtils.writeByte(dest, tokenOff, 240);
                    dOff = LZ4UnsafeUtils.writeLen(runLen - 15, dest, dOff);
                } else {
                    UnsafeUtils.writeByte(dest, tokenOff, runLen << 4);
                }
                LZ4UnsafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
                dOff+=runLen;
                do {
                    UnsafeUtils.writeShortLE(dest, dOff, (short)(sOff - ref));
                    int matchLen = LZ4UnsafeUtils.commonBytes(src, ref+=4, sOff+=4, srcLimit);
                    if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                        throw new LZ4Exception("maxDestLen is too small");
                    }
                    sOff+=matchLen;
                    if (matchLen >= 15) {
                        UnsafeUtils.writeByte(dest, tokenOff, UnsafeUtils.readByte(dest, tokenOff) | 15);
                        dOff = LZ4UnsafeUtils.writeLen(matchLen - 15, dest, dOff);
                    } else {
                        UnsafeUtils.writeByte(dest, tokenOff, UnsafeUtils.readByte(dest, tokenOff) | matchLen);
                    }
                    if (sOff > mflimit) {
                        anchor = sOff;
                        break block0;
                    }
                    UnsafeUtils.writeShort(hashTable, LZ4Utils.hash64k(UnsafeUtils.readInt(src, sOff - 2)), sOff - 2 - srcOff);
                    int h = LZ4Utils.hash64k(UnsafeUtils.readInt(src, sOff));
                    ref = srcOff + UnsafeUtils.readShort(hashTable, h);
                    UnsafeUtils.writeShort(hashTable, h, sOff - srcOff);
                    if (!LZ4UnsafeUtils.readIntEquals(src, sOff, ref)) break;
                    tokenOff = dOff++;
                    UnsafeUtils.writeByte(dest, tokenOff, 0);
                } while (true);
                anchor = sOff++;
            } while (true);
        }
        dOff = LZ4UnsafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int maxDestLen) {
        UnsafeUtils.checkRange(src, srcOff, srcLen);
        UnsafeUtils.checkRange(dest, destOff, maxDestLen);
        int destEnd = destOff + maxDestLen;
        if (srcLen < 65547) {
            return LZ4JavaUnsafeCompressor.compress64k(src, srcOff, srcLen, dest, destOff, destEnd);
        }
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        int[] hashTable = new int[4096];
        Arrays.fill(hashTable, anchor);
        block0 : do {
            int back;
            int ref;
            int forwardOff = sOff;
            int step = 1;
            int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
            do {
                sOff = forwardOff;
                if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                int h = LZ4Utils.hash(UnsafeUtils.readInt(src, sOff));
                ref = UnsafeUtils.readInt(hashTable, h);
                back = sOff - ref;
                UnsafeUtils.writeInt(hashTable, h, sOff);
            } while (back >= 65536 || !LZ4UnsafeUtils.readIntEquals(src, ref, sOff));
            int excess = LZ4UnsafeUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
            ref-=excess;
            int runLen = (sOff-=excess) - anchor;
            int tokenOff = dOff++;
            if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                throw new LZ4Exception("maxDestLen is too small");
            }
            if (runLen >= 15) {
                UnsafeUtils.writeByte(dest, tokenOff, 240);
                dOff = LZ4UnsafeUtils.writeLen(runLen - 15, dest, dOff);
            } else {
                UnsafeUtils.writeByte(dest, tokenOff, runLen << 4);
            }
            LZ4UnsafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
            dOff+=runLen;
            do {
                UnsafeUtils.writeShortLE(dest, dOff, back);
                int matchLen = LZ4UnsafeUtils.commonBytes(src, ref + 4, sOff+=4, srcLimit);
                if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                sOff+=matchLen;
                if (matchLen >= 15) {
                    UnsafeUtils.writeByte(dest, tokenOff, UnsafeUtils.readByte(dest, tokenOff) | 15);
                    dOff = LZ4UnsafeUtils.writeLen(matchLen - 15, dest, dOff);
                } else {
                    UnsafeUtils.writeByte(dest, tokenOff, UnsafeUtils.readByte(dest, tokenOff) | matchLen);
                }
                if (sOff > mflimit) {
                    anchor = sOff;
                    break block0;
                }
                UnsafeUtils.writeInt(hashTable, LZ4Utils.hash(UnsafeUtils.readInt(src, sOff - 2)), sOff - 2);
                int h = LZ4Utils.hash(UnsafeUtils.readInt(src, sOff));
                ref = UnsafeUtils.readInt(hashTable, h);
                UnsafeUtils.writeInt(hashTable, h, sOff);
                back = sOff - ref;
                if (back >= 65536) break;
                if (!LZ4UnsafeUtils.readIntEquals(src, ref, sOff)) break;
                tokenOff = dOff++;
                UnsafeUtils.writeByte(dest, tokenOff, 0);
            } while (true);
            anchor = sOff++;
        } while (true);
        dOff = LZ4UnsafeUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    static int compress64k(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int destEnd) {
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        if (srcLen >= 13) {
            short[] hashTable = new short[8192];
            block0 : do {
                int ref;
                int forwardOff = sOff;
                int step = 1;
                int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
                do {
                    sOff = forwardOff;
                    if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                    int h = LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff));
                    ref = srcOff + UnsafeUtils.readShort(hashTable, h);
                    UnsafeUtils.writeShort(hashTable, h, sOff - srcOff);
                } while (!LZ4ByteBufferUtils.readIntEquals(src, ref, sOff));
                int excess = LZ4ByteBufferUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
                ref-=excess;
                int runLen = (sOff-=excess) - anchor;
                int tokenOff = dOff++;
                if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                if (runLen >= 15) {
                    ByteBufferUtils.writeByte(dest, tokenOff, 240);
                    dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
                } else {
                    ByteBufferUtils.writeByte(dest, tokenOff, runLen << 4);
                }
                LZ4ByteBufferUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
                dOff+=runLen;
                do {
                    ByteBufferUtils.writeShortLE(dest, dOff, (short)(sOff - ref));
                    int matchLen = LZ4ByteBufferUtils.commonBytes(src, ref+=4, sOff+=4, srcLimit);
                    if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                        throw new LZ4Exception("maxDestLen is too small");
                    }
                    sOff+=matchLen;
                    if (matchLen >= 15) {
                        ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | 15);
                        dOff = LZ4ByteBufferUtils.writeLen(matchLen - 15, dest, dOff);
                    } else {
                        ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | matchLen);
                    }
                    if (sOff > mflimit) {
                        anchor = sOff;
                        break block0;
                    }
                    UnsafeUtils.writeShort(hashTable, LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff - 2)), sOff - 2 - srcOff);
                    int h = LZ4Utils.hash64k(ByteBufferUtils.readInt(src, sOff));
                    ref = srcOff + UnsafeUtils.readShort(hashTable, h);
                    UnsafeUtils.writeShort(hashTable, h, sOff - srcOff);
                    if (!LZ4ByteBufferUtils.readIntEquals(src, sOff, ref)) break;
                    tokenOff = dOff++;
                    ByteBufferUtils.writeByte(dest, tokenOff, 0);
                } while (true);
                anchor = sOff++;
            } while (true);
        }
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }

    @Override
    public int compress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int maxDestLen) {
        if (src.hasArray() && dest.hasArray()) {
            return this.compress(src.array(), srcOff, srcLen, dest.array(), destOff, maxDestLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, maxDestLen);
        int destEnd = destOff + maxDestLen;
        if (srcLen < 65547) {
            return LZ4JavaUnsafeCompressor.compress64k(src, srcOff, srcLen, dest, destOff, destEnd);
        }
        int srcEnd = srcOff + srcLen;
        int srcLimit = srcEnd - 5;
        int mflimit = srcEnd - 12;
        int sOff = srcOff;
        int dOff = destOff;
        int anchor = sOff++;
        int[] hashTable = new int[4096];
        Arrays.fill(hashTable, anchor);
        block0 : do {
            int back;
            int ref;
            int forwardOff = sOff;
            int step = 1;
            int searchMatchNb = 1 << LZ4Constants.SKIP_STRENGTH;
            do {
                sOff = forwardOff;
                if ((forwardOff+=(step = searchMatchNb++ >>> LZ4Constants.SKIP_STRENGTH)) > mflimit) break block0;
                int h = LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff));
                ref = UnsafeUtils.readInt(hashTable, h);
                back = sOff - ref;
                UnsafeUtils.writeInt(hashTable, h, sOff);
            } while (back >= 65536 || !LZ4ByteBufferUtils.readIntEquals(src, ref, sOff));
            int excess = LZ4ByteBufferUtils.commonBytesBackward(src, ref, sOff, srcOff, anchor);
            ref-=excess;
            int runLen = (sOff-=excess) - anchor;
            int tokenOff = dOff++;
            if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
                throw new LZ4Exception("maxDestLen is too small");
            }
            if (runLen >= 15) {
                ByteBufferUtils.writeByte(dest, tokenOff, 240);
                dOff = LZ4ByteBufferUtils.writeLen(runLen - 15, dest, dOff);
            } else {
                ByteBufferUtils.writeByte(dest, tokenOff, runLen << 4);
            }
            LZ4ByteBufferUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
            dOff+=runLen;
            do {
                ByteBufferUtils.writeShortLE(dest, dOff, back);
                int matchLen = LZ4ByteBufferUtils.commonBytes(src, ref + 4, sOff+=4, srcLimit);
                if ((dOff+=2) + 6 + (matchLen >>> 8) > destEnd) {
                    throw new LZ4Exception("maxDestLen is too small");
                }
                sOff+=matchLen;
                if (matchLen >= 15) {
                    ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | 15);
                    dOff = LZ4ByteBufferUtils.writeLen(matchLen - 15, dest, dOff);
                } else {
                    ByteBufferUtils.writeByte(dest, tokenOff, ByteBufferUtils.readByte(dest, tokenOff) | matchLen);
                }
                if (sOff > mflimit) {
                    anchor = sOff;
                    break block0;
                }
                UnsafeUtils.writeInt(hashTable, LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff - 2)), sOff - 2);
                int h = LZ4Utils.hash(ByteBufferUtils.readInt(src, sOff));
                ref = UnsafeUtils.readInt(hashTable, h);
                UnsafeUtils.writeInt(hashTable, h, sOff);
                back = sOff - ref;
                if (back >= 65536) break;
                if (!LZ4ByteBufferUtils.readIntEquals(src, ref, sOff)) break;
                tokenOff = dOff++;
                ByteBufferUtils.writeByte(dest, tokenOff, 0);
            } while (true);
            anchor = sOff++;
        } while (true);
        dOff = LZ4ByteBufferUtils.lastLiterals(src, anchor, srcEnd - anchor, dest, dOff, destEnd);
        return dOff - destOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4FastDecompressor;
import net.jpountz.lz4.LZ4UnsafeUtils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;

final class LZ4JavaUnsafeFastDecompressor
extends LZ4FastDecompressor {
    public static final LZ4FastDecompressor INSTANCE = new LZ4JavaUnsafeFastDecompressor();

    LZ4JavaUnsafeFastDecompressor() {
    }

    @Override
    public int decompress(byte[] src, int srcOff, byte[] dest, int destOff, int destLen) {
        int literalLen;
        int literalCopyEnd;
        UnsafeUtils.checkRange(src, srcOff);
        UnsafeUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (UnsafeUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Malformed input at " + srcOff);
            }
            return 1;
        }
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = UnsafeUtils.readByte(src, sOff) & 255;
            ++sOff;
            literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                do {
                    byte by = UnsafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                } while (true);
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8) {
                if (literalCopyEnd != destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                } else {
                    break;
                }
            }
            LZ4UnsafeUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = UnsafeUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                do {
                    byte by = UnsafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                } while (true);
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4UnsafeUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4UnsafeUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        LZ4UnsafeUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
        dOff = literalCopyEnd;
        return (sOff+=literalLen) - srcOff;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, ByteBuffer dest, int destOff, int destLen) {
        int literalLen;
        int literalCopyEnd;
        if (src.hasArray() && dest.hasArray()) {
            return this.decompress(src.array(), srcOff, dest.array(), destOff, destLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff);
        ByteBufferUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (ByteBufferUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Malformed input at " + srcOff);
            }
            return 1;
        }
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = ByteBufferUtils.readByte(src, sOff) & 255;
            ++sOff;
            literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                do {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                } while (true);
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8) {
                if (literalCopyEnd != destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                } else {
                    break;
                }
            }
            LZ4ByteBufferUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = ByteBufferUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                do {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                } while (true);
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4ByteBufferUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        LZ4ByteBufferUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
        dOff = literalCopyEnd;
        return (sOff+=literalLen) - srcOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteBuffer;
import net.jpountz.lz4.LZ4ByteBufferUtils;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4SafeDecompressor;
import net.jpountz.lz4.LZ4UnsafeUtils;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;

final class LZ4JavaUnsafeSafeDecompressor
extends LZ4SafeDecompressor {
    public static final LZ4SafeDecompressor INSTANCE = new LZ4JavaUnsafeSafeDecompressor();

    LZ4JavaUnsafeSafeDecompressor() {
    }

    @Override
    public int decompress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff, int destLen) {
        int literalCopyEnd;
        UnsafeUtils.checkRange(src, srcOff, srcLen);
        UnsafeUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (srcLen != 1 || UnsafeUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Output buffer too small");
            }
            return 0;
        }
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = UnsafeUtils.readByte(src, sOff) & 255;
            ++sOff;
            int literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = UnsafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                }
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8 || sOff + literalLen > srcEnd - 8) {
                if (literalCopyEnd > destEnd) {
                    throw new LZ4Exception();
                }
                if (sOff + literalLen != srcEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4UnsafeUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
                sOff+=literalLen;
                break;
            }
            LZ4UnsafeUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = UnsafeUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = UnsafeUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                }
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4UnsafeUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4UnsafeUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        dOff = literalCopyEnd;
        return dOff - destOff;
    }

    @Override
    public int decompress(ByteBuffer src, int srcOff, int srcLen, ByteBuffer dest, int destOff, int destLen) {
        int literalCopyEnd;
        if (src.hasArray() && dest.hasArray()) {
            return this.decompress(src.array(), srcOff, srcLen, dest.array(), destOff, destLen);
        }
        src = ByteBufferUtils.inNativeByteOrder(src);
        dest = ByteBufferUtils.inNativeByteOrder(dest);
        ByteBufferUtils.checkRange(src, srcOff, srcLen);
        ByteBufferUtils.checkRange(dest, destOff, destLen);
        if (destLen == 0) {
            if (srcLen != 1 || ByteBufferUtils.readByte(src, srcOff) != 0) {
                throw new LZ4Exception("Output buffer too small");
            }
            return 0;
        }
        int srcEnd = srcOff + srcLen;
        int destEnd = destOff + destLen;
        int sOff = srcOff;
        int dOff = destOff;
        do {
            int matchCopyEnd;
            int token = ByteBufferUtils.readByte(src, sOff) & 255;
            ++sOff;
            int literalLen = token >>> 4;
            if (literalLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    literalLen+=255;
                }
                literalLen+=len & 255;
            }
            if ((literalCopyEnd = dOff + literalLen) > destEnd - 8 || sOff + literalLen > srcEnd - 8) {
                if (literalCopyEnd > destEnd) {
                    throw new LZ4Exception();
                }
                if (sOff + literalLen != srcEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeArraycopy(src, sOff, dest, dOff, literalLen);
                sOff+=literalLen;
                break;
            }
            LZ4ByteBufferUtils.wildArraycopy(src, sOff, dest, dOff, literalLen);
            dOff = literalCopyEnd;
            int matchDec = ByteBufferUtils.readShortLE(src, sOff+=literalLen);
            sOff+=2;
            int matchOff = dOff - matchDec;
            if (matchOff < destOff) {
                throw new LZ4Exception("Malformed input at " + sOff);
            }
            int matchLen = token & 15;
            if (matchLen == 15) {
                int len = -1;
                while (sOff < srcEnd) {
                    byte by = ByteBufferUtils.readByte(src, sOff++);
                    len = by;
                    if (by != -1) break;
                    matchLen+=255;
                }
                matchLen+=len & 255;
            }
            if ((matchCopyEnd = dOff + (matchLen+=4)) > destEnd - 8) {
                if (matchCopyEnd > destEnd) {
                    throw new LZ4Exception("Malformed input at " + sOff);
                }
                LZ4ByteBufferUtils.safeIncrementalCopy(dest, matchOff, dOff, matchLen);
            } else {
                LZ4ByteBufferUtils.wildIncrementalCopy(dest, matchOff, dOff, matchCopyEnd);
            }
            dOff = matchCopyEnd;
        } while (true);
        dOff = literalCopyEnd;
        return dOff - destOff;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.Arrays;
import net.jpountz.lz4.LZ4UnknownSizeDecompressor;

public abstract class LZ4SafeDecompressor
implements LZ4UnknownSizeDecompressor {
    @Override
    public abstract int decompress(byte[] var1, int var2, int var3, byte[] var4, int var5, int var6);

    public abstract int decompress(ByteBuffer var1, int var2, int var3, ByteBuffer var4, int var5, int var6);

    @Override
    public final int decompress(byte[] src, int srcOff, int srcLen, byte[] dest, int destOff) {
        return this.decompress(src, srcOff, srcLen, dest, destOff, dest.length - destOff);
    }

    public final int decompress(byte[] src, byte[] dest) {
        return this.decompress(src, 0, src.length, dest, 0);
    }

    public final byte[] decompress(byte[] src, int srcOff, int srcLen, int maxDestLen) {
        byte[] decompressed = new byte[maxDestLen];
        int decompressedLength = this.decompress(src, srcOff, srcLen, decompressed, 0, maxDestLen);
        if (decompressedLength != decompressed.length) {
            decompressed = Arrays.copyOf(decompressed, decompressedLength);
        }
        return decompressed;
    }

    public final byte[] decompress(byte[] src, int maxDestLen) {
        return this.decompress(src, 0, src.length, maxDestLen);
    }

    public final void decompress(ByteBuffer src, ByteBuffer dest) {
        int decompressed = this.decompress(src, src.position(), src.remaining(), dest, dest.position(), dest.remaining());
        src.position(src.limit());
        dest.position(dest.position() + decompressed);
    }

    public String toString() {
        return this.getClass().getSimpleName();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4Utils;
import net.jpountz.util.SafeUtils;

final class LZ4SafeUtils
extends Enum<LZ4SafeUtils> {
    private static final /* synthetic */ LZ4SafeUtils[] $VALUES;

    public static LZ4SafeUtils[] values() {
        return (LZ4SafeUtils[])$VALUES.clone();
    }

    public static LZ4SafeUtils valueOf(String name) {
        return (LZ4SafeUtils)Enum.valueOf(LZ4SafeUtils.class, name);
    }

    private LZ4SafeUtils() {
        super(string, n);
    }

    static int hash(byte[] buf, int i) {
        return LZ4Utils.hash(SafeUtils.readInt(buf, i));
    }

    static int hash64k(byte[] buf, int i) {
        return LZ4Utils.hash64k(SafeUtils.readInt(buf, i));
    }

    static boolean readIntEquals(byte[] buf, int i, int j) {
        return buf[i] == buf[j] && buf[i + 1] == buf[j + 1] && buf[i + 2] == buf[j + 2] && buf[i + 3] == buf[j + 3];
    }

    static void safeIncrementalCopy(byte[] dest, int matchOff, int dOff, int matchLen) {
        for (int i = 0; i < matchLen; ++i) {
            dest[dOff + i] = dest[matchOff + i];
        }
    }

    static void wildIncrementalCopy(byte[] dest, int matchOff, int dOff, int matchCopyEnd) {
        do {
            LZ4SafeUtils.copy8Bytes(dest, matchOff, dest, dOff);
            matchOff+=8;
        } while ((dOff+=8) < matchCopyEnd);
    }

    static void copy8Bytes(byte[] src, int sOff, byte[] dest, int dOff) {
        for (int i = 0; i < 8; ++i) {
            dest[dOff + i] = src[sOff + i];
        }
    }

    static int commonBytes(byte[] b, int o1, int o2, int limit) {
        int count = 0;
        while (o2 < limit && b[o1++] == b[o2++]) {
            ++count;
        }
        return count;
    }

    static int commonBytesBackward(byte[] b, int o1, int o2, int l1, int l2) {
        int count = 0;
        while (o1 > l1 && o2 > l2 && b[--o1] == b[--o2]) {
            ++count;
        }
        return count;
    }

    static void safeArraycopy(byte[] src, int sOff, byte[] dest, int dOff, int len) {
        System.arraycopy(src, sOff, dest, dOff, len);
    }

    static void wildArraycopy(byte[] src, int sOff, byte[] dest, int dOff, int len) {
        try {
            for (int i = 0; i < len; i+=8) {
                LZ4SafeUtils.copy8Bytes(src, sOff + i, dest, dOff + i);
            }
        }
        catch (ArrayIndexOutOfBoundsException e) {
            throw new LZ4Exception("Malformed input at offset " + sOff);
        }
    }

    static int encodeSequence(byte[] src, int anchor, int matchOff, int matchRef, int matchLen, byte[] dest, int dOff, int destEnd) {
        int token;
        int runLen = matchOff - anchor;
        int tokenOff = dOff++;
        if (dOff + runLen + 8 + (runLen >>> 8) > destEnd) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        if (runLen >= 15) {
            token = -16;
            dOff = LZ4SafeUtils.writeLen(runLen - 15, dest, dOff);
        } else {
            token = runLen << 4;
        }
        LZ4SafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
        dOff+=runLen;
        int matchDec = matchOff - matchRef;
        dest[dOff++] = (byte)matchDec;
        dest[dOff++] = (byte)(matchDec >>> 8);
        if (dOff + 6 + ((matchLen-=4) >>> 8) > destEnd) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        if (matchLen >= 15) {
            token|=15;
            dOff = LZ4SafeUtils.writeLen(matchLen - 15, dest, dOff);
        } else {
            token|=matchLen;
        }
        dest[tokenOff] = (byte)token;
        return dOff;
    }

    static int lastLiterals(byte[] src, int sOff, int srcLen, byte[] dest, int dOff, int destEnd) {
        int runLen = srcLen;
        if (dOff + runLen + 1 + (runLen + 255 - 15) / 255 > destEnd) {
            throw new LZ4Exception();
        }
        if (runLen >= 15) {
            dest[dOff++] = -16;
            dOff = LZ4SafeUtils.writeLen(runLen - 15, dest, dOff);
        } else {
            dest[dOff++] = (byte)(runLen << 4);
        }
        System.arraycopy(src, sOff, dest, dOff, runLen);
        return dOff+=runLen;
    }

    static int writeLen(int len, byte[] dest, int dOff) {
        while (len >= 255) {
            dest[dOff++] = -1;
            len-=255;
        }
        dest[dOff++] = (byte)len;
        return dOff;
    }

    static void copyTo(Match m1, Match m2) {
        m2.len = m1.len;
        m2.start = m1.start;
        m2.ref = m1.ref;
    }

    static {
        $VALUES = new LZ4SafeUtils[0];
    }

    static class Match {
        int start;
        int ref;
        int len;

        Match() {
        }

        void fix(int correction) {
            this.start+=correction;
            this.ref+=correction;
            this.len-=correction;
        }

        int end() {
            return this.start + this.len;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

@Deprecated
public interface LZ4UnknownSizeDecompressor {
    public int decompress(byte[] var1, int var2, int var3, byte[] var4, int var5, int var6);

    public int decompress(byte[] var1, int var2, int var3, byte[] var4, int var5);
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

import java.nio.ByteOrder;
import net.jpountz.lz4.LZ4Exception;
import net.jpountz.lz4.LZ4SafeUtils;
import net.jpountz.util.UnsafeUtils;
import net.jpountz.util.Utils;

final class LZ4UnsafeUtils
extends Enum<LZ4UnsafeUtils> {
    private static final /* synthetic */ LZ4UnsafeUtils[] $VALUES;

    public static LZ4UnsafeUtils[] values() {
        return (LZ4UnsafeUtils[])$VALUES.clone();
    }

    public static LZ4UnsafeUtils valueOf(String name) {
        return (LZ4UnsafeUtils)Enum.valueOf(LZ4UnsafeUtils.class, name);
    }

    private LZ4UnsafeUtils() {
        super(string, n);
    }

    static void safeArraycopy(byte[] src, int srcOff, byte[] dest, int destOff, int len) {
        int fastLen = len & -8;
        LZ4UnsafeUtils.wildArraycopy(src, srcOff, dest, destOff, fastLen);
        int slowLen = len & 7;
        for (int i = 0; i < slowLen; ++i) {
            UnsafeUtils.writeByte(dest, destOff + fastLen + i, UnsafeUtils.readByte(src, srcOff + fastLen + i));
        }
    }

    static void wildArraycopy(byte[] src, int srcOff, byte[] dest, int destOff, int len) {
        for (int i = 0; i < len; i+=8) {
            UnsafeUtils.writeLong(dest, destOff + i, UnsafeUtils.readLong(src, srcOff + i));
        }
    }

    static void wildIncrementalCopy(byte[] dest, int matchOff, int dOff, int matchCopyEnd) {
        if (dOff - matchOff < 4) {
            for (int i = 0; i < 4; ++i) {
                UnsafeUtils.writeByte(dest, dOff + i, UnsafeUtils.readByte(dest, matchOff + i));
            }
            int dec = 0;
            assert (dOff >= matchOff && (dOff+=4) - (matchOff+=4) < 8);
            switch (dOff - matchOff) {
                case 1: {
                    matchOff-=3;
                    break;
                }
                case 2: {
                    matchOff-=2;
                    break;
                }
                case 3: {
                    matchOff-=3;
                    dec = -1;
                    break;
                }
                case 5: {
                    dec = 1;
                    break;
                }
                case 6: {
                    dec = 2;
                    break;
                }
                case 7: {
                    dec = 3;
                    break;
                }
            }
            UnsafeUtils.writeInt(dest, dOff, UnsafeUtils.readInt(dest, matchOff));
            dOff+=4;
            matchOff-=dec;
        } else if (dOff - matchOff < 8) {
            UnsafeUtils.writeLong(dest, dOff, UnsafeUtils.readLong(dest, matchOff));
            dOff+=dOff - matchOff;
        }
        while (dOff < matchCopyEnd) {
            UnsafeUtils.writeLong(dest, dOff, UnsafeUtils.readLong(dest, matchOff));
            dOff+=8;
            matchOff+=8;
        }
    }

    static void safeIncrementalCopy(byte[] dest, int matchOff, int dOff, int matchLen) {
        for (int i = 0; i < matchLen; ++i) {
            dest[dOff + i] = dest[matchOff + i];
            UnsafeUtils.writeByte(dest, dOff + i, UnsafeUtils.readByte(dest, matchOff + i));
        }
    }

    static int readShortLittleEndian(byte[] src, int srcOff) {
        short s = UnsafeUtils.readShort(src, srcOff);
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            s = Short.reverseBytes(s);
        }
        return s & 65535;
    }

    static void writeShortLittleEndian(byte[] dest, int destOff, int value) {
        short s = (short)value;
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            s = Short.reverseBytes(s);
        }
        UnsafeUtils.writeShort(dest, destOff, s);
    }

    static boolean readIntEquals(byte[] src, int ref, int sOff) {
        return UnsafeUtils.readInt(src, ref) == UnsafeUtils.readInt(src, sOff);
    }

    static int commonBytes(byte[] src, int ref, int sOff, int srcLimit) {
        int matchLen = 0;
        while (sOff <= srcLimit - 8) {
            if (UnsafeUtils.readLong(src, sOff) == UnsafeUtils.readLong(src, ref)) {
                matchLen+=8;
                ref+=8;
                sOff+=8;
                continue;
            }
            int zeroBits = Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN ? Long.numberOfLeadingZeros(UnsafeUtils.readLong(src, sOff) ^ UnsafeUtils.readLong(src, ref)) : Long.numberOfTrailingZeros(UnsafeUtils.readLong(src, sOff) ^ UnsafeUtils.readLong(src, ref));
            return matchLen + (zeroBits >>> 3);
        }
        while (sOff < srcLimit && UnsafeUtils.readByte(src, ref++) == UnsafeUtils.readByte(src, sOff++)) {
            ++matchLen;
        }
        return matchLen;
    }

    static int writeLen(int len, byte[] dest, int dOff) {
        while (len >= 255) {
            UnsafeUtils.writeByte(dest, dOff++, 255);
            len-=255;
        }
        UnsafeUtils.writeByte(dest, dOff++, len);
        return dOff;
    }

    static int encodeSequence(byte[] src, int anchor, int matchOff, int matchRef, int matchLen, byte[] dest, int dOff, int destEnd) {
        int token;
        int runLen = matchOff - anchor;
        int tokenOff = dOff++;
        if (runLen >= 15) {
            token = -16;
            dOff = LZ4UnsafeUtils.writeLen(runLen - 15, dest, dOff);
        } else {
            token = runLen << 4;
        }
        LZ4UnsafeUtils.wildArraycopy(src, anchor, dest, dOff, runLen);
        dOff+=runLen;
        int matchDec = matchOff - matchRef;
        dest[dOff++] = (byte)matchDec;
        dest[dOff++] = (byte)(matchDec >>> 8);
        if (dOff + 6 + ((matchLen-=4) >>> 8) > destEnd) {
            throw new LZ4Exception("maxDestLen is too small");
        }
        if (matchLen >= 15) {
            token|=15;
            dOff = LZ4UnsafeUtils.writeLen(matchLen - 15, dest, dOff);
        } else {
            token|=matchLen;
        }
        dest[tokenOff] = (byte)token;
        return dOff;
    }

    static int commonBytesBackward(byte[] b, int o1, int o2, int l1, int l2) {
        int count = 0;
        while (o1 > l1 && o2 > l2 && UnsafeUtils.readByte(b, --o1) == UnsafeUtils.readByte(b, --o2)) {
            ++count;
        }
        return count;
    }

    static int lastLiterals(byte[] src, int sOff, int srcLen, byte[] dest, int dOff, int destEnd) {
        return LZ4SafeUtils.lastLiterals(src, sOff, srcLen, dest, dOff, destEnd);
    }

    static {
        $VALUES = new LZ4UnsafeUtils[0];
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.lz4;

final class LZ4Utils
extends Enum<LZ4Utils> {
    private static final int MAX_INPUT_SIZE = 2113929216;
    private static final /* synthetic */ LZ4Utils[] $VALUES;

    public static LZ4Utils[] values() {
        return (LZ4Utils[])$VALUES.clone();
    }

    public static LZ4Utils valueOf(String name) {
        return (LZ4Utils)Enum.valueOf(LZ4Utils.class, name);
    }

    private LZ4Utils() {
        super(string, n);
    }

    static int maxCompressedLength(int length) {
        if (length < 0) {
            throw new IllegalArgumentException("length must be >= 0, got " + length);
        }
        if (length >= 2113929216) {
            throw new IllegalArgumentException("length must be < 2113929216");
        }
        return length + length / 255 + 16;
    }

    static int hash(int i) {
        return i * -1640531535 >>> 20;
    }

    static int hash64k(int i) {
        return i * -1640531535 >>> 19;
    }

    static int hashHC(int i) {
        return i * -1640531535 >>> 17;
    }

    static void copyTo(Match m1, Match m2) {
        m2.len = m1.len;
        m2.start = m1.start;
        m2.ref = m1.ref;
    }

    static {
        $VALUES = new LZ4Utils[0];
    }

    static class Match {
        int start;
        int ref;
        int len;

        Match() {
        }

        void fix(int correction) {
            this.start+=correction;
            this.ref+=correction;
            this.len-=correction;
        }

        int end() {
            return this.start + this.len;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.util;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.ReadOnlyBufferException;
import net.jpountz.util.SafeUtils;
import net.jpountz.util.Utils;

public final class ByteBufferUtils
extends Enum<ByteBufferUtils> {
    private static final /* synthetic */ ByteBufferUtils[] $VALUES;

    public static ByteBufferUtils[] values() {
        return (ByteBufferUtils[])$VALUES.clone();
    }

    public static ByteBufferUtils valueOf(String name) {
        return (ByteBufferUtils)Enum.valueOf(ByteBufferUtils.class, name);
    }

    private ByteBufferUtils() {
        super(string, n);
    }

    public static void checkRange(ByteBuffer buf, int off, int len) {
        SafeUtils.checkLength(len);
        if (len > 0) {
            ByteBufferUtils.checkRange(buf, off);
            ByteBufferUtils.checkRange(buf, off + len - 1);
        }
    }

    public static void checkRange(ByteBuffer buf, int off) {
        if (off < 0 || off >= buf.capacity()) {
            throw new ArrayIndexOutOfBoundsException(off);
        }
    }

    public static ByteBuffer inLittleEndianOrder(ByteBuffer buf) {
        if (buf.order().equals(ByteOrder.LITTLE_ENDIAN)) {
            return buf;
        }
        return buf.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    }

    public static ByteBuffer inNativeByteOrder(ByteBuffer buf) {
        if (buf.order().equals(Utils.NATIVE_BYTE_ORDER)) {
            return buf;
        }
        return buf.duplicate().order(Utils.NATIVE_BYTE_ORDER);
    }

    public static byte readByte(ByteBuffer buf, int i) {
        return buf.get(i);
    }

    public static void writeInt(ByteBuffer buf, int i, int v) {
        assert (buf.order() == Utils.NATIVE_BYTE_ORDER);
        buf.putInt(i, v);
    }

    public static int readInt(ByteBuffer buf, int i) {
        assert (buf.order() == Utils.NATIVE_BYTE_ORDER);
        return buf.getInt(i);
    }

    public static int readIntLE(ByteBuffer buf, int i) {
        assert (buf.order() == ByteOrder.LITTLE_ENDIAN);
        return buf.getInt(i);
    }

    public static void writeLong(ByteBuffer buf, int i, long v) {
        assert (buf.order() == Utils.NATIVE_BYTE_ORDER);
        buf.putLong(i, v);
    }

    public static long readLong(ByteBuffer buf, int i) {
        assert (buf.order() == Utils.NATIVE_BYTE_ORDER);
        return buf.getLong(i);
    }

    public static long readLongLE(ByteBuffer buf, int i) {
        assert (buf.order() == ByteOrder.LITTLE_ENDIAN);
        return buf.getLong(i);
    }

    public static void writeByte(ByteBuffer dest, int off, int i) {
        dest.put(off, (byte)i);
    }

    public static void writeShortLE(ByteBuffer dest, int off, int i) {
        dest.put(off, (byte)i);
        dest.put(off + 1, (byte)(i >>> 8));
    }

    public static void checkNotReadOnly(ByteBuffer buffer) {
        if (buffer.isReadOnly()) {
            throw new ReadOnlyBufferException();
        }
    }

    public static int readShortLE(ByteBuffer buf, int i) {
        return buf.get(i) & 255 | (buf.get(i + 1) & 255) << 8;
    }

    static {
        $VALUES = new ByteBufferUtils[0];
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

public final class Native
extends Enum<Native> {
    private static boolean loaded;
    private static final /* synthetic */ Native[] $VALUES;

    public static Native[] values() {
        return (Native[])$VALUES.clone();
    }

    public static Native valueOf(String name) {
        return (Native)Enum.valueOf(Native.class, name);
    }

    private Native() {
        super(string, n);
    }

    private static String arch() {
        return System.getProperty("os.arch");
    }

    private static OS os() {
        String osName = System.getProperty("os.name");
        if (osName.contains((CharSequence)"Linux")) {
            return OS.LINUX;
        }
        if (osName.contains((CharSequence)"Mac")) {
            return OS.MAC;
        }
        if (osName.contains((CharSequence)"Windows")) {
            return OS.WINDOWS;
        }
        if (osName.contains((CharSequence)"Solaris") || osName.contains((CharSequence)"SunOS")) {
            return OS.SOLARIS;
        }
        throw new UnsupportedOperationException("Unsupported operating system: " + osName);
    }

    private static String resourceName() {
        OS os = Native.os();
        return "/" + os.name + "/" + Native.arch() + "/liblz4-java." + os.libExtension;
    }

    public static synchronized boolean isLoaded() {
        return loaded;
    }

    public static synchronized void load() {
        if (loaded) {
            return;
        }
        String resourceName = Native.resourceName();
        InputStream is = Native.class.getResourceAsStream(resourceName);
        if (is == null) {
            throw new UnsupportedOperationException("Unsupported OS/arch, cannot find " + resourceName + ". Please try building from source.");
        }
        try {
            File tempLib = File.createTempFile("liblz4-java", "." + Native.os().libExtension);
            FileOutputStream out = new FileOutputStream(tempLib);
            try {
                int read;
                byte[] buf = new byte[4096];
                while ((read = is.read(buf)) != -1) {
                    out.write(buf, 0, read);
                }
                try {
                    out.close();
                    out = null;
                }
                catch (IOException e) {
                    // empty catch block
                }
                System.load(tempLib.getAbsolutePath());
                loaded = true;
            }
            finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                }
                catch (IOException e) {}
                if (tempLib != null && tempLib.exists()) {
                    if (!loaded) {
                        tempLib.delete();
                    } else {
                        tempLib.deleteOnExit();
                    }
                }
            }
        }
        catch (IOException e) {
            throw new ExceptionInInitializerError("Cannot unpack liblz4-java");
        }
    }

    static {
        $VALUES = new Native[0];
        loaded = false;
    }

    private static enum OS {
        WINDOWS("win32", "so"),
        LINUX("linux", "so"),
        MAC("darwin", "dylib"),
        SOLARIS("solaris", "so");
        
        public final String name;
        public final String libExtension;

        private OS(String name, String libExtension) {
            this.name = name;
            this.libExtension = libExtension;
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.util;

import java.nio.ByteOrder;
import net.jpountz.util.Utils;

public final class SafeUtils
extends Enum<SafeUtils> {
    private static final /* synthetic */ SafeUtils[] $VALUES;

    public static SafeUtils[] values() {
        return (SafeUtils[])$VALUES.clone();
    }

    public static SafeUtils valueOf(String name) {
        return (SafeUtils)Enum.valueOf(SafeUtils.class, name);
    }

    private SafeUtils() {
        super(string, n);
    }

    public static void checkRange(byte[] buf, int off) {
        if (off < 0 || off >= buf.length) {
            throw new ArrayIndexOutOfBoundsException(off);
        }
    }

    public static void checkRange(byte[] buf, int off, int len) {
        SafeUtils.checkLength(len);
        if (len > 0) {
            SafeUtils.checkRange(buf, off);
            SafeUtils.checkRange(buf, off + len - 1);
        }
    }

    public static void checkLength(int len) {
        if (len < 0) {
            throw new IllegalArgumentException("lengths must be >= 0");
        }
    }

    public static byte readByte(byte[] buf, int i) {
        return buf[i];
    }

    public static int readIntBE(byte[] buf, int i) {
        return (buf[i] & 255) << 24 | (buf[i + 1] & 255) << 16 | (buf[i + 2] & 255) << 8 | buf[i + 3] & 255;
    }

    public static int readIntLE(byte[] buf, int i) {
        return buf[i] & 255 | (buf[i + 1] & 255) << 8 | (buf[i + 2] & 255) << 16 | (buf[i + 3] & 255) << 24;
    }

    public static int readInt(byte[] buf, int i) {
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            return SafeUtils.readIntBE(buf, i);
        }
        return SafeUtils.readIntLE(buf, i);
    }

    public static long readLongLE(byte[] buf, int i) {
        return (long)buf[i] & 255 | ((long)buf[i + 1] & 255) << 8 | ((long)buf[i + 2] & 255) << 16 | ((long)buf[i + 3] & 255) << 24 | ((long)buf[i + 4] & 255) << 32 | ((long)buf[i + 5] & 255) << 40 | ((long)buf[i + 6] & 255) << 48 | ((long)buf[i + 7] & 255) << 56;
    }

    public static void writeShortLE(byte[] buf, int off, int v) {
        buf[off++] = (byte)v;
        buf[off++] = (byte)(v >>> 8);
    }

    public static void writeInt(int[] buf, int off, int v) {
        buf[off] = v;
    }

    public static int readInt(int[] buf, int off) {
        return buf[off];
    }

    public static void writeByte(byte[] dest, int off, int i) {
        dest[off] = (byte)i;
    }

    public static void writeShort(short[] buf, int off, int v) {
        buf[off] = (short)v;
    }

    public static int readShortLE(byte[] buf, int i) {
        return buf[i] & 255 | (buf[i + 1] & 255) << 8;
    }

    public static int readShort(short[] buf, int off) {
        return buf[off] & 65535;
    }

    static {
        $VALUES = new SafeUtils[0];
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.util;

import java.nio.ByteOrder;
import net.jpountz.util.SafeUtils;
import net.jpountz.util.Utils;
import sun.misc.Unsafe;

public final class UnsafeUtils
extends Enum<UnsafeUtils> {
    private static final Unsafe UNSAFE;
    private static final long BYTE_ARRAY_OFFSET;
    private static final int BYTE_ARRAY_SCALE;
    private static final long INT_ARRAY_OFFSET;
    private static final int INT_ARRAY_SCALE;
    private static final long SHORT_ARRAY_OFFSET;
    private static final int SHORT_ARRAY_SCALE;
    private static final /* synthetic */ UnsafeUtils[] $VALUES;

    public static UnsafeUtils[] values() {
        return (UnsafeUtils[])$VALUES.clone();
    }

    public static UnsafeUtils valueOf(String name) {
        return (UnsafeUtils)Enum.valueOf(UnsafeUtils.class, name);
    }

    private UnsafeUtils() {
        super(string, n);
    }

    public static void checkRange(byte[] buf, int off) {
        SafeUtils.checkRange(buf, off);
    }

    public static void checkRange(byte[] buf, int off, int len) {
        SafeUtils.checkRange(buf, off, len);
    }

    public static void checkLength(int len) {
        SafeUtils.checkLength(len);
    }

    public static byte readByte(byte[] src, int srcOff) {
        return UNSAFE.getByte((Object)src, BYTE_ARRAY_OFFSET + (long)(BYTE_ARRAY_SCALE * srcOff));
    }

    public static void writeByte(byte[] src, int srcOff, byte value) {
        UNSAFE.putByte((Object)src, BYTE_ARRAY_OFFSET + (long)(BYTE_ARRAY_SCALE * srcOff), value);
    }

    public static void writeByte(byte[] src, int srcOff, int value) {
        UnsafeUtils.writeByte(src, srcOff, (byte)value);
    }

    public static long readLong(byte[] src, int srcOff) {
        return UNSAFE.getLong((Object)src, BYTE_ARRAY_OFFSET + (long)srcOff);
    }

    public static long readLongLE(byte[] src, int srcOff) {
        long i = UnsafeUtils.readLong(src, srcOff);
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            i = Long.reverseBytes(i);
        }
        return i;
    }

    public static void writeLong(byte[] dest, int destOff, long value) {
        UNSAFE.putLong((Object)dest, BYTE_ARRAY_OFFSET + (long)destOff, value);
    }

    public static int readInt(byte[] src, int srcOff) {
        return UNSAFE.getInt((Object)src, BYTE_ARRAY_OFFSET + (long)srcOff);
    }

    public static int readIntLE(byte[] src, int srcOff) {
        int i = UnsafeUtils.readInt(src, srcOff);
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            i = Integer.reverseBytes(i);
        }
        return i;
    }

    public static void writeInt(byte[] dest, int destOff, int value) {
        UNSAFE.putInt((Object)dest, BYTE_ARRAY_OFFSET + (long)destOff, value);
    }

    public static short readShort(byte[] src, int srcOff) {
        return UNSAFE.getShort((Object)src, BYTE_ARRAY_OFFSET + (long)srcOff);
    }

    public static int readShortLE(byte[] src, int srcOff) {
        short s = UnsafeUtils.readShort(src, srcOff);
        if (Utils.NATIVE_BYTE_ORDER == ByteOrder.BIG_ENDIAN) {
            s = Short.reverseBytes(s);
        }
        return s & 65535;
    }

    public static void writeShort(byte[] dest, int destOff, short value) {
        UNSAFE.putShort((Object)dest, BYTE_ARRAY_OFFSET + (long)destOff, value);
    }

    public static void writeShortLE(byte[] buf, int off, int v) {
        UnsafeUtils.writeByte(buf, off, (byte)v);
        UnsafeUtils.writeByte(buf, off + 1, (byte)(v >>> 8));
    }

    public static int readInt(int[] src, int srcOff) {
        return UNSAFE.getInt((Object)src, INT_ARRAY_OFFSET + (long)(INT_ARRAY_SCALE * srcOff));
    }

    public static void writeInt(int[] dest, int destOff, int value) {
        UNSAFE.putInt((Object)dest, INT_ARRAY_OFFSET + (long)(INT_ARRAY_SCALE * destOff), value);
    }

    public static int readShort(short[] src, int srcOff) {
        return UNSAFE.getShort((Object)src, SHORT_ARRAY_OFFSET + (long)(SHORT_ARRAY_SCALE * srcOff)) & 65535;
    }

    public static void writeShort(short[] dest, int destOff, int value) {
        UNSAFE.putShort((Object)dest, SHORT_ARRAY_OFFSET + (long)(SHORT_ARRAY_SCALE * destOff), (short)value);
    }

    static {
        $VALUES = new UnsafeUtils[0];
        try {
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            UNSAFE = (Unsafe)theUnsafe.get(null);
            BYTE_ARRAY_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);
            BYTE_ARRAY_SCALE = UNSAFE.arrayIndexScale(byte[].class);
            INT_ARRAY_OFFSET = UNSAFE.arrayBaseOffset(int[].class);
            INT_ARRAY_SCALE = UNSAFE.arrayIndexScale(int[].class);
            SHORT_ARRAY_OFFSET = UNSAFE.arrayBaseOffset(short[].class);
            SHORT_ARRAY_SCALE = UNSAFE.arrayIndexScale(short[].class);
        }
        catch (IllegalAccessException e) {
            throw new ExceptionInInitializerError("Cannot access Unsafe");
        }
        catch (NoSuchFieldException e) {
            throw new ExceptionInInitializerError("Cannot access Unsafe");
        }
        catch (SecurityException e) {
            throw new ExceptionInInitializerError("Cannot access Unsafe");
        }
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.util;

import java.nio.ByteOrder;

public final class Utils
extends Enum<Utils> {
    public static final ByteOrder NATIVE_BYTE_ORDER;
    private static final boolean unalignedAccessAllowed;
    private static final /* synthetic */ Utils[] $VALUES;

    public static Utils[] values() {
        return (Utils[])$VALUES.clone();
    }

    public static Utils valueOf(String name) {
        return (Utils)Enum.valueOf(Utils.class, name);
    }

    private Utils() {
        super(string, n);
    }

    public static boolean isUnalignedAccessAllowed() {
        return unalignedAccessAllowed;
    }

    static {
        $VALUES = new Utils[0];
        NATIVE_BYTE_ORDER = ByteOrder.nativeOrder();
        String arch = System.getProperty("os.arch");
        unalignedAccessAllowed = arch.equals("i386") || arch.equals("x86") || arch.equals("amd64") || arch.equals("x86_64");
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.xxhash.StreamingXXHash32;

abstract class AbstractStreamingXXHash32Java
extends StreamingXXHash32 {
    int v1;
    int v2;
    int v3;
    int v4;
    int memSize;
    long totalLen;
    final byte[] memory = new byte[16];

    AbstractStreamingXXHash32Java(int seed) {
        super(seed);
        this.reset();
    }

    @Override
    public void reset() {
        this.v1 = this.seed + -1640531535 + -2048144777;
        this.v2 = this.seed + -2048144777;
        this.v3 = this.seed + 0;
        this.v4 = this.seed - -1640531535;
        this.totalLen = 0;
        this.memSize = 0;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.xxhash.StreamingXXHash64;

abstract class AbstractStreamingXXHash64Java
extends StreamingXXHash64 {
    int memSize;
    long v1;
    long v2;
    long v3;
    long v4;
    long totalLen;
    final byte[] memory = new byte[32];

    AbstractStreamingXXHash64Java(long seed) {
        super(seed);
        this.reset();
    }

    @Override
    public void reset() {
        this.v1 = this.seed + -7046029288634856825L + -4417276706812531889L;
        this.v2 = this.seed + -4417276706812531889L;
        this.v3 = this.seed + 0;
        this.v4 = this.seed - -7046029288634856825L;
        this.totalLen = 0;
        this.memSize = 0;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.util.zip.Checksum;

public abstract class StreamingXXHash32 {
    final int seed;

    StreamingXXHash32(int seed) {
        this.seed = seed;
    }

    public abstract int getValue();

    public abstract void update(byte[] var1, int var2, int var3);

    public abstract void reset();

    public String toString() {
        return this.getClass().getSimpleName() + "(seed=" + this.seed + ")";
    }

    public final Checksum asChecksum() {
        return new Checksum(){

            @Override
            public long getValue() {
                return (long)StreamingXXHash32.this.getValue() & 0xFFFFFFF;
            }

            @Override
            public void reset() {
                StreamingXXHash32.this.reset();
            }

            @Override
            public void update(int b) {
                StreamingXXHash32.this.update(new byte[]{(byte)b}, 0, 1);
            }

            @Override
            public void update(byte[] b, int off, int len) {
                StreamingXXHash32.this.update(b, off, len);
            }

            public String toString() {
                return StreamingXXHash32.this.toString();
            }
        };
    }

    static interface Factory {
        public StreamingXXHash32 newStreamingHash(int var1);
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.xxhash.StreamingXXHash32;
import net.jpountz.xxhash.XXHashJNI;

final class StreamingXXHash32JNI
extends StreamingXXHash32 {
    private long state;

    StreamingXXHash32JNI(int seed) {
        super(seed);
        this.state = XXHashJNI.XXH32_init(seed);
    }

    private void checkState() {
        if (this.state == 0) {
            throw new AssertionError((Object)"Already finalized");
        }
    }

    @Override
    public void reset() {
        this.checkState();
        XXHashJNI.XXH32_free(this.state);
        this.state = XXHashJNI.XXH32_init(this.seed);
    }

    @Override
    public int getValue() {
        this.checkState();
        return XXHashJNI.XXH32_digest(this.state);
    }

    @Override
    public void update(byte[] bytes, int off, int len) {
        this.checkState();
        XXHashJNI.XXH32_update(this.state, bytes, off, len);
    }

    protected void finalize() throws Throwable {
        super.finalize();
        XXHashJNI.XXH32_free(this.state);
        this.state = 0;
    }

    static class Factory
    implements StreamingXXHash32.Factory {
        public static final StreamingXXHash32.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash32 newStreamingHash(int seed) {
            return new StreamingXXHash32JNI(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.AbstractStreamingXXHash32Java;
import net.jpountz.xxhash.StreamingXXHash32;

final class StreamingXXHash32JavaSafe
extends AbstractStreamingXXHash32Java {
    StreamingXXHash32JavaSafe(int seed) {
        super(seed);
    }

    @Override
    public int getValue() {
        int off;
        int h32 = this.totalLen >= 16 ? Integer.rotateLeft(this.v1, 1) + Integer.rotateLeft(this.v2, 7) + Integer.rotateLeft(this.v3, 12) + Integer.rotateLeft(this.v4, 18) : this.seed + 374761393;
        h32 = (int)((long)h32 + this.totalLen);
        for (off = 0; off <= this.memSize - 4; off+=4) {
            h32+=SafeUtils.readIntLE(this.memory, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
        }
        while (off < this.memSize) {
            h32+=(SafeUtils.readByte(this.memory, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }

    @Override
    public void update(byte[] buf, int off, int len) {
        SafeUtils.checkRange(buf, off, len);
        this.totalLen+=(long)len;
        if (this.memSize + len < 16) {
            System.arraycopy(buf, off, this.memory, this.memSize, len);
            this.memSize+=len;
            return;
        }
        int end = off + len;
        if (this.memSize > 0) {
            System.arraycopy(buf, off, this.memory, this.memSize, 16 - this.memSize);
            this.v1+=SafeUtils.readIntLE(this.memory, 0) * -2048144777;
            this.v1 = Integer.rotateLeft(this.v1, 13);
            this.v1*=-1640531535;
            this.v2+=SafeUtils.readIntLE(this.memory, 4) * -2048144777;
            this.v2 = Integer.rotateLeft(this.v2, 13);
            this.v2*=-1640531535;
            this.v3+=SafeUtils.readIntLE(this.memory, 8) * -2048144777;
            this.v3 = Integer.rotateLeft(this.v3, 13);
            this.v3*=-1640531535;
            this.v4+=SafeUtils.readIntLE(this.memory, 12) * -2048144777;
            this.v4 = Integer.rotateLeft(this.v4, 13);
            this.v4*=-1640531535;
            off+=16 - this.memSize;
            this.memSize = 0;
        }
        int limit = end - 16;
        int v1 = this.v1;
        int v2 = this.v2;
        int v3 = this.v3;
        int v4 = this.v4;
        while (off <= limit) {
            v1+=SafeUtils.readIntLE(buf, off) * -2048144777;
            v1 = Integer.rotateLeft(v1, 13);
            v1*=-1640531535;
            v2+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v2 = Integer.rotateLeft(v2, 13);
            v2*=-1640531535;
            v3+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v3 = Integer.rotateLeft(v3, 13);
            v3*=-1640531535;
            v4+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v4 = Integer.rotateLeft(v4, 13);
            v4*=-1640531535;
            off+=4;
        }
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
        if (off < end) {
            System.arraycopy(buf, off, this.memory, 0, end - off);
            this.memSize = end - off;
        }
    }

    static class Factory
    implements StreamingXXHash32.Factory {
        public static final StreamingXXHash32.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash32 newStreamingHash(int seed) {
            return new StreamingXXHash32JavaSafe(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.util.SafeUtils;
import net.jpountz.util.UnsafeUtils;
import net.jpountz.xxhash.AbstractStreamingXXHash32Java;
import net.jpountz.xxhash.StreamingXXHash32;

final class StreamingXXHash32JavaUnsafe
extends AbstractStreamingXXHash32Java {
    StreamingXXHash32JavaUnsafe(int seed) {
        super(seed);
    }

    @Override
    public int getValue() {
        int off;
        int h32 = this.totalLen >= 16 ? Integer.rotateLeft(this.v1, 1) + Integer.rotateLeft(this.v2, 7) + Integer.rotateLeft(this.v3, 12) + Integer.rotateLeft(this.v4, 18) : this.seed + 374761393;
        h32 = (int)((long)h32 + this.totalLen);
        for (off = 0; off <= this.memSize - 4; off+=4) {
            h32+=UnsafeUtils.readIntLE(this.memory, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
        }
        while (off < this.memSize) {
            h32+=(UnsafeUtils.readByte(this.memory, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }

    @Override
    public void update(byte[] buf, int off, int len) {
        SafeUtils.checkRange(buf, off, len);
        this.totalLen+=(long)len;
        if (this.memSize + len < 16) {
            System.arraycopy(buf, off, this.memory, this.memSize, len);
            this.memSize+=len;
            return;
        }
        int end = off + len;
        if (this.memSize > 0) {
            System.arraycopy(buf, off, this.memory, this.memSize, 16 - this.memSize);
            this.v1+=UnsafeUtils.readIntLE(this.memory, 0) * -2048144777;
            this.v1 = Integer.rotateLeft(this.v1, 13);
            this.v1*=-1640531535;
            this.v2+=UnsafeUtils.readIntLE(this.memory, 4) * -2048144777;
            this.v2 = Integer.rotateLeft(this.v2, 13);
            this.v2*=-1640531535;
            this.v3+=UnsafeUtils.readIntLE(this.memory, 8) * -2048144777;
            this.v3 = Integer.rotateLeft(this.v3, 13);
            this.v3*=-1640531535;
            this.v4+=UnsafeUtils.readIntLE(this.memory, 12) * -2048144777;
            this.v4 = Integer.rotateLeft(this.v4, 13);
            this.v4*=-1640531535;
            off+=16 - this.memSize;
            this.memSize = 0;
        }
        int limit = end - 16;
        int v1 = this.v1;
        int v2 = this.v2;
        int v3 = this.v3;
        int v4 = this.v4;
        while (off <= limit) {
            v1+=UnsafeUtils.readIntLE(buf, off) * -2048144777;
            v1 = Integer.rotateLeft(v1, 13);
            v1*=-1640531535;
            v2+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v2 = Integer.rotateLeft(v2, 13);
            v2*=-1640531535;
            v3+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v3 = Integer.rotateLeft(v3, 13);
            v3*=-1640531535;
            v4+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
            v4 = Integer.rotateLeft(v4, 13);
            v4*=-1640531535;
            off+=4;
        }
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
        if (off < end) {
            System.arraycopy(buf, off, this.memory, 0, end - off);
            this.memSize = end - off;
        }
    }

    static class Factory
    implements StreamingXXHash32.Factory {
        public static final StreamingXXHash32.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash32 newStreamingHash(int seed) {
            return new StreamingXXHash32JavaUnsafe(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.util.zip.Checksum;

public abstract class StreamingXXHash64 {
    final long seed;

    StreamingXXHash64(long seed) {
        this.seed = seed;
    }

    public abstract long getValue();

    public abstract void update(byte[] var1, int var2, int var3);

    public abstract void reset();

    public String toString() {
        return this.getClass().getSimpleName() + "(seed=" + this.seed + ")";
    }

    public final Checksum asChecksum() {
        return new Checksum(){

            @Override
            public long getValue() {
                return StreamingXXHash64.this.getValue();
            }

            @Override
            public void reset() {
                StreamingXXHash64.this.reset();
            }

            @Override
            public void update(int b) {
                StreamingXXHash64.this.update(new byte[]{(byte)b}, 0, 1);
            }

            @Override
            public void update(byte[] b, int off, int len) {
                StreamingXXHash64.this.update(b, off, len);
            }

            public String toString() {
                return StreamingXXHash64.this.toString();
            }
        };
    }

    static interface Factory {
        public StreamingXXHash64 newStreamingHash(long var1);
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.xxhash.StreamingXXHash64;
import net.jpountz.xxhash.XXHashJNI;

final class StreamingXXHash64JNI
extends StreamingXXHash64 {
    private long state;

    StreamingXXHash64JNI(long seed) {
        super(seed);
        this.state = XXHashJNI.XXH64_init(seed);
    }

    private void checkState() {
        if (this.state == 0) {
            throw new AssertionError((Object)"Already finalized");
        }
    }

    @Override
    public void reset() {
        this.checkState();
        XXHashJNI.XXH64_free(this.state);
        this.state = XXHashJNI.XXH64_init(this.seed);
    }

    @Override
    public long getValue() {
        this.checkState();
        return XXHashJNI.XXH64_digest(this.state);
    }

    @Override
    public void update(byte[] bytes, int off, int len) {
        this.checkState();
        XXHashJNI.XXH64_update(this.state, bytes, off, len);
    }

    protected void finalize() throws Throwable {
        super.finalize();
        XXHashJNI.XXH64_free(this.state);
        this.state = 0;
    }

    static class Factory
    implements StreamingXXHash64.Factory {
        public static final StreamingXXHash64.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash64 newStreamingHash(long seed) {
            return new StreamingXXHash64JNI(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.AbstractStreamingXXHash64Java;
import net.jpountz.xxhash.StreamingXXHash64;

final class StreamingXXHash64JavaSafe
extends AbstractStreamingXXHash64Java {
    StreamingXXHash64JavaSafe(long seed) {
        super(seed);
    }

    @Override
    public long getValue() {
        long h64;
        int off;
        if (this.totalLen >= 32) {
            long v1 = this.v1;
            long v2 = this.v2;
            long v3 = this.v3;
            long v4 = this.v4;
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = this.seed + 2870177450012600261L;
        }
        h64+=this.totalLen;
        for (off = 0; off <= this.memSize - 8; off+=8) {
            long k1 = SafeUtils.readLongLE(this.memory, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
        }
        if (off <= this.memSize - 4) {
            h64^=((long)SafeUtils.readIntLE(this.memory, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < this.memSize) {
            h64^=(long)(this.memory[off] & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }

    @Override
    public void update(byte[] buf, int off, int len) {
        SafeUtils.checkRange(buf, off, len);
        this.totalLen+=(long)len;
        if (this.memSize + len < 32) {
            System.arraycopy(buf, off, this.memory, this.memSize, len);
            this.memSize+=len;
            return;
        }
        int end = off + len;
        if (this.memSize > 0) {
            System.arraycopy(buf, off, this.memory, this.memSize, 32 - this.memSize);
            this.v1+=SafeUtils.readLongLE(this.memory, 0) * -4417276706812531889L;
            this.v1 = Long.rotateLeft(this.v1, 31);
            this.v1*=-7046029288634856825L;
            this.v2+=SafeUtils.readLongLE(this.memory, 8) * -4417276706812531889L;
            this.v2 = Long.rotateLeft(this.v2, 31);
            this.v2*=-7046029288634856825L;
            this.v3+=SafeUtils.readLongLE(this.memory, 16) * -4417276706812531889L;
            this.v3 = Long.rotateLeft(this.v3, 31);
            this.v3*=-7046029288634856825L;
            this.v4+=SafeUtils.readLongLE(this.memory, 24) * -4417276706812531889L;
            this.v4 = Long.rotateLeft(this.v4, 31);
            this.v4*=-7046029288634856825L;
            off+=32 - this.memSize;
            this.memSize = 0;
        }
        int limit = end - 32;
        long v1 = this.v1;
        long v2 = this.v2;
        long v3 = this.v3;
        long v4 = this.v4;
        while (off <= limit) {
            v1+=SafeUtils.readLongLE(buf, off) * -4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            v1*=-7046029288634856825L;
            v2+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            v2*=-7046029288634856825L;
            v3+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            v3*=-7046029288634856825L;
            v4+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            v4*=-7046029288634856825L;
            off+=8;
        }
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
        if (off < end) {
            System.arraycopy(buf, off, this.memory, 0, end - off);
            this.memSize = end - off;
        }
    }

    static class Factory
    implements StreamingXXHash64.Factory {
        public static final StreamingXXHash64.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash64 newStreamingHash(long seed) {
            return new StreamingXXHash64JavaSafe(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import net.jpountz.util.SafeUtils;
import net.jpountz.util.UnsafeUtils;
import net.jpountz.xxhash.AbstractStreamingXXHash64Java;
import net.jpountz.xxhash.StreamingXXHash64;

final class StreamingXXHash64JavaUnsafe
extends AbstractStreamingXXHash64Java {
    StreamingXXHash64JavaUnsafe(long seed) {
        super(seed);
    }

    @Override
    public long getValue() {
        long h64;
        int off;
        if (this.totalLen >= 32) {
            long v1 = this.v1;
            long v2 = this.v2;
            long v3 = this.v3;
            long v4 = this.v4;
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = this.seed + 2870177450012600261L;
        }
        h64+=this.totalLen;
        for (off = 0; off <= this.memSize - 8; off+=8) {
            long k1 = UnsafeUtils.readLongLE(this.memory, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
        }
        if (off <= this.memSize - 4) {
            h64^=((long)UnsafeUtils.readIntLE(this.memory, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < this.memSize) {
            h64^=(long)(this.memory[off] & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }

    @Override
    public void update(byte[] buf, int off, int len) {
        SafeUtils.checkRange(buf, off, len);
        this.totalLen+=(long)len;
        if (this.memSize + len < 32) {
            System.arraycopy(buf, off, this.memory, this.memSize, len);
            this.memSize+=len;
            return;
        }
        int end = off + len;
        if (this.memSize > 0) {
            System.arraycopy(buf, off, this.memory, this.memSize, 32 - this.memSize);
            this.v1+=UnsafeUtils.readLongLE(this.memory, 0) * -4417276706812531889L;
            this.v1 = Long.rotateLeft(this.v1, 31);
            this.v1*=-7046029288634856825L;
            this.v2+=UnsafeUtils.readLongLE(this.memory, 8) * -4417276706812531889L;
            this.v2 = Long.rotateLeft(this.v2, 31);
            this.v2*=-7046029288634856825L;
            this.v3+=UnsafeUtils.readLongLE(this.memory, 16) * -4417276706812531889L;
            this.v3 = Long.rotateLeft(this.v3, 31);
            this.v3*=-7046029288634856825L;
            this.v4+=UnsafeUtils.readLongLE(this.memory, 24) * -4417276706812531889L;
            this.v4 = Long.rotateLeft(this.v4, 31);
            this.v4*=-7046029288634856825L;
            off+=32 - this.memSize;
            this.memSize = 0;
        }
        int limit = end - 32;
        long v1 = this.v1;
        long v2 = this.v2;
        long v3 = this.v3;
        long v4 = this.v4;
        while (off <= limit) {
            v1+=UnsafeUtils.readLongLE(buf, off) * -4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            v1*=-7046029288634856825L;
            v2+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            v2*=-7046029288634856825L;
            v3+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            v3*=-7046029288634856825L;
            v4+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            v4*=-7046029288634856825L;
            off+=8;
        }
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
        if (off < end) {
            System.arraycopy(buf, off, this.memory, 0, end - off);
            this.memSize = end - off;
        }
    }

    static class Factory
    implements StreamingXXHash64.Factory {
        public static final StreamingXXHash64.Factory INSTANCE = new Factory();

        Factory() {
        }

        @Override
        public StreamingXXHash64 newStreamingHash(long seed) {
            return new StreamingXXHash64JavaUnsafe(seed);
        }
    }

}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.Buffer;
import java.nio.ByteBuffer;

public abstract class XXHash32 {
    public abstract int hash(byte[] var1, int var2, int var3, int var4);

    public abstract int hash(ByteBuffer var1, int var2, int var3, int var4);

    public final int hash(ByteBuffer buf, int seed) {
        int hash = this.hash(buf, buf.position(), buf.remaining(), seed);
        buf.position(buf.limit());
        return hash;
    }

    public String toString() {
        return this.getClass().getSimpleName();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.XXHash32;
import net.jpountz.xxhash.XXHashFactory;
import net.jpountz.xxhash.XXHashJNI;

final class XXHash32JNI
extends XXHash32 {
    public static final XXHash32 INSTANCE = new XXHash32JNI();
    private static XXHash32 SAFE_INSTANCE;

    XXHash32JNI() {
    }

    @Override
    public int hash(byte[] buf, int off, int len, int seed) {
        SafeUtils.checkRange(buf, off, len);
        return XXHashJNI.XXH32(buf, off, len, seed);
    }

    @Override
    public int hash(ByteBuffer buf, int off, int len, int seed) {
        if (buf.isDirect()) {
            ByteBufferUtils.checkRange(buf, off, len);
            return XXHashJNI.XXH32BB(buf, off, len, seed);
        }
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        XXHash32 safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = XXHash32JNI.SAFE_INSTANCE = XXHashFactory.safeInstance().hash32();
        }
        return safeInstance.hash(buf, off, len, seed);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.XXHash32;

final class XXHash32JavaSafe
extends XXHash32 {
    public static final XXHash32 INSTANCE = new XXHash32JavaSafe();

    XXHash32JavaSafe() {
    }

    @Override
    public int hash(byte[] buf, int off, int len, int seed) {
        int h32;
        SafeUtils.checkRange(buf, off, len);
        int end = off + len;
        if (len >= 16) {
            int limit = end - 16;
            int v1 = seed + -1640531535 + -2048144777;
            int v2 = seed + -2048144777;
            int v3 = seed + 0;
            int v4 = seed - -1640531535;
            do {
                v1+=SafeUtils.readIntLE(buf, off) * -2048144777;
                v1 = Integer.rotateLeft(v1, 13);
                v1*=-1640531535;
                v2+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v2 = Integer.rotateLeft(v2, 13);
                v2*=-1640531535;
                v3+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v3 = Integer.rotateLeft(v3, 13);
                v3*=-1640531535;
                v4+=SafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v4 = Integer.rotateLeft(v4, 13);
                v4*=-1640531535;
            } while ((off+=4) <= limit);
            h32 = Integer.rotateLeft(v1, 1) + Integer.rotateLeft(v2, 7) + Integer.rotateLeft(v3, 12) + Integer.rotateLeft(v4, 18);
        } else {
            h32 = seed + 374761393;
        }
        h32+=len;
        while (off <= end - 4) {
            h32+=SafeUtils.readIntLE(buf, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
            off+=4;
        }
        while (off < end) {
            h32+=(SafeUtils.readByte(buf, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }

    @Override
    public int hash(ByteBuffer buf, int off, int len, int seed) {
        int h32;
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        ByteBufferUtils.checkRange(buf, off, len);
        buf = ByteBufferUtils.inLittleEndianOrder(buf);
        int end = off + len;
        if (len >= 16) {
            int limit = end - 16;
            int v1 = seed + -1640531535 + -2048144777;
            int v2 = seed + -2048144777;
            int v3 = seed + 0;
            int v4 = seed - -1640531535;
            do {
                v1+=ByteBufferUtils.readIntLE(buf, off) * -2048144777;
                v1 = Integer.rotateLeft(v1, 13);
                v1*=-1640531535;
                v2+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v2 = Integer.rotateLeft(v2, 13);
                v2*=-1640531535;
                v3+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v3 = Integer.rotateLeft(v3, 13);
                v3*=-1640531535;
                v4+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v4 = Integer.rotateLeft(v4, 13);
                v4*=-1640531535;
            } while ((off+=4) <= limit);
            h32 = Integer.rotateLeft(v1, 1) + Integer.rotateLeft(v2, 7) + Integer.rotateLeft(v3, 12) + Integer.rotateLeft(v4, 18);
        } else {
            h32 = seed + 374761393;
        }
        h32+=len;
        while (off <= end - 4) {
            h32+=ByteBufferUtils.readIntLE(buf, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
            off+=4;
        }
        while (off < end) {
            h32+=(ByteBufferUtils.readByte(buf, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;
import net.jpountz.xxhash.XXHash32;

final class XXHash32JavaUnsafe
extends XXHash32 {
    public static final XXHash32 INSTANCE = new XXHash32JavaUnsafe();

    XXHash32JavaUnsafe() {
    }

    @Override
    public int hash(byte[] buf, int off, int len, int seed) {
        int h32;
        UnsafeUtils.checkRange(buf, off, len);
        int end = off + len;
        if (len >= 16) {
            int limit = end - 16;
            int v1 = seed + -1640531535 + -2048144777;
            int v2 = seed + -2048144777;
            int v3 = seed + 0;
            int v4 = seed - -1640531535;
            do {
                v1+=UnsafeUtils.readIntLE(buf, off) * -2048144777;
                v1 = Integer.rotateLeft(v1, 13);
                v1*=-1640531535;
                v2+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v2 = Integer.rotateLeft(v2, 13);
                v2*=-1640531535;
                v3+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v3 = Integer.rotateLeft(v3, 13);
                v3*=-1640531535;
                v4+=UnsafeUtils.readIntLE(buf, off+=4) * -2048144777;
                v4 = Integer.rotateLeft(v4, 13);
                v4*=-1640531535;
            } while ((off+=4) <= limit);
            h32 = Integer.rotateLeft(v1, 1) + Integer.rotateLeft(v2, 7) + Integer.rotateLeft(v3, 12) + Integer.rotateLeft(v4, 18);
        } else {
            h32 = seed + 374761393;
        }
        h32+=len;
        while (off <= end - 4) {
            h32+=UnsafeUtils.readIntLE(buf, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
            off+=4;
        }
        while (off < end) {
            h32+=(UnsafeUtils.readByte(buf, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }

    @Override
    public int hash(ByteBuffer buf, int off, int len, int seed) {
        int h32;
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        ByteBufferUtils.checkRange(buf, off, len);
        buf = ByteBufferUtils.inLittleEndianOrder(buf);
        int end = off + len;
        if (len >= 16) {
            int limit = end - 16;
            int v1 = seed + -1640531535 + -2048144777;
            int v2 = seed + -2048144777;
            int v3 = seed + 0;
            int v4 = seed - -1640531535;
            do {
                v1+=ByteBufferUtils.readIntLE(buf, off) * -2048144777;
                v1 = Integer.rotateLeft(v1, 13);
                v1*=-1640531535;
                v2+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v2 = Integer.rotateLeft(v2, 13);
                v2*=-1640531535;
                v3+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v3 = Integer.rotateLeft(v3, 13);
                v3*=-1640531535;
                v4+=ByteBufferUtils.readIntLE(buf, off+=4) * -2048144777;
                v4 = Integer.rotateLeft(v4, 13);
                v4*=-1640531535;
            } while ((off+=4) <= limit);
            h32 = Integer.rotateLeft(v1, 1) + Integer.rotateLeft(v2, 7) + Integer.rotateLeft(v3, 12) + Integer.rotateLeft(v4, 18);
        } else {
            h32 = seed + 374761393;
        }
        h32+=len;
        while (off <= end - 4) {
            h32+=ByteBufferUtils.readIntLE(buf, off) * -1028477379;
            h32 = Integer.rotateLeft(h32, 17) * 668265263;
            off+=4;
        }
        while (off < end) {
            h32+=(ByteBufferUtils.readByte(buf, off) & 255) * 374761393;
            h32 = Integer.rotateLeft(h32, 11) * -1640531535;
            ++off;
        }
        h32^=h32 >>> 15;
        h32*=-2048144777;
        h32^=h32 >>> 13;
        h32*=-1028477379;
        h32^=h32 >>> 16;
        return h32;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.Buffer;
import java.nio.ByteBuffer;

public abstract class XXHash64 {
    public abstract long hash(byte[] var1, int var2, int var3, long var4);

    public abstract long hash(ByteBuffer var1, int var2, int var3, long var4);

    public final long hash(ByteBuffer buf, long seed) {
        long hash = this.hash(buf, buf.position(), buf.remaining(), seed);
        buf.position(buf.limit());
        return hash;
    }

    public String toString() {
        return this.getClass().getSimpleName();
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.XXHash64;
import net.jpountz.xxhash.XXHashFactory;
import net.jpountz.xxhash.XXHashJNI;

final class XXHash64JNI
extends XXHash64 {
    public static final XXHash64 INSTANCE = new XXHash64JNI();
    private static XXHash64 SAFE_INSTANCE;

    XXHash64JNI() {
    }

    @Override
    public long hash(byte[] buf, int off, int len, long seed) {
        SafeUtils.checkRange(buf, off, len);
        return XXHashJNI.XXH64(buf, off, len, seed);
    }

    @Override
    public long hash(ByteBuffer buf, int off, int len, long seed) {
        if (buf.isDirect()) {
            ByteBufferUtils.checkRange(buf, off, len);
            return XXHashJNI.XXH64BB(buf, off, len, seed);
        }
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        XXHash64 safeInstance = SAFE_INSTANCE;
        if (safeInstance == null) {
            safeInstance = XXHash64JNI.SAFE_INSTANCE = XXHashFactory.safeInstance().hash64();
        }
        return safeInstance.hash(buf, off, len, seed);
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.SafeUtils;
import net.jpountz.xxhash.XXHash64;

final class XXHash64JavaSafe
extends XXHash64 {
    public static final XXHash64 INSTANCE = new XXHash64JavaSafe();

    XXHash64JavaSafe() {
    }

    @Override
    public long hash(byte[] buf, int off, int len, long seed) {
        long h64;
        SafeUtils.checkRange(buf, off, len);
        int end = off + len;
        if (len >= 32) {
            int limit = end - 32;
            long v1 = seed + -7046029288634856825L + -4417276706812531889L;
            long v2 = seed + -4417276706812531889L;
            long v3 = seed + 0;
            long v4 = seed - -7046029288634856825L;
            do {
                v1+=SafeUtils.readLongLE(buf, off) * -4417276706812531889L;
                v1 = Long.rotateLeft(v1, 31);
                v1*=-7046029288634856825L;
                v2+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v2 = Long.rotateLeft(v2, 31);
                v2*=-7046029288634856825L;
                v3+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v3 = Long.rotateLeft(v3, 31);
                v3*=-7046029288634856825L;
                v4+=SafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v4 = Long.rotateLeft(v4, 31);
                v4*=-7046029288634856825L;
            } while ((off+=8) <= limit);
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = seed + 2870177450012600261L;
        }
        h64+=(long)len;
        while (off <= end - 8) {
            long k1 = SafeUtils.readLongLE(buf, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
            off+=8;
        }
        if (off <= end - 4) {
            h64^=((long)SafeUtils.readIntLE(buf, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < end) {
            h64^=(long)(SafeUtils.readByte(buf, off) & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }

    @Override
    public long hash(ByteBuffer buf, int off, int len, long seed) {
        long h64;
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        ByteBufferUtils.checkRange(buf, off, len);
        buf = ByteBufferUtils.inLittleEndianOrder(buf);
        int end = off + len;
        if (len >= 32) {
            int limit = end - 32;
            long v1 = seed + -7046029288634856825L + -4417276706812531889L;
            long v2 = seed + -4417276706812531889L;
            long v3 = seed + 0;
            long v4 = seed - -7046029288634856825L;
            do {
                v1+=ByteBufferUtils.readLongLE(buf, off) * -4417276706812531889L;
                v1 = Long.rotateLeft(v1, 31);
                v1*=-7046029288634856825L;
                v2+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v2 = Long.rotateLeft(v2, 31);
                v2*=-7046029288634856825L;
                v3+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v3 = Long.rotateLeft(v3, 31);
                v3*=-7046029288634856825L;
                v4+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v4 = Long.rotateLeft(v4, 31);
                v4*=-7046029288634856825L;
            } while ((off+=8) <= limit);
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = seed + 2870177450012600261L;
        }
        h64+=(long)len;
        while (off <= end - 8) {
            long k1 = ByteBufferUtils.readLongLE(buf, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
            off+=8;
        }
        if (off <= end - 4) {
            h64^=((long)ByteBufferUtils.readIntLE(buf, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < end) {
            h64^=(long)(ByteBufferUtils.readByte(buf, off) & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.ByteBufferUtils;
import net.jpountz.util.UnsafeUtils;
import net.jpountz.xxhash.XXHash64;

final class XXHash64JavaUnsafe
extends XXHash64 {
    public static final XXHash64 INSTANCE = new XXHash64JavaUnsafe();

    XXHash64JavaUnsafe() {
    }

    @Override
    public long hash(byte[] buf, int off, int len, long seed) {
        long h64;
        UnsafeUtils.checkRange(buf, off, len);
        int end = off + len;
        if (len >= 32) {
            int limit = end - 32;
            long v1 = seed + -7046029288634856825L + -4417276706812531889L;
            long v2 = seed + -4417276706812531889L;
            long v3 = seed + 0;
            long v4 = seed - -7046029288634856825L;
            do {
                v1+=UnsafeUtils.readLongLE(buf, off) * -4417276706812531889L;
                v1 = Long.rotateLeft(v1, 31);
                v1*=-7046029288634856825L;
                v2+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v2 = Long.rotateLeft(v2, 31);
                v2*=-7046029288634856825L;
                v3+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v3 = Long.rotateLeft(v3, 31);
                v3*=-7046029288634856825L;
                v4+=UnsafeUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v4 = Long.rotateLeft(v4, 31);
                v4*=-7046029288634856825L;
            } while ((off+=8) <= limit);
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = seed + 2870177450012600261L;
        }
        h64+=(long)len;
        while (off <= end - 8) {
            long k1 = UnsafeUtils.readLongLE(buf, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
            off+=8;
        }
        if (off <= end - 4) {
            h64^=((long)UnsafeUtils.readIntLE(buf, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < end) {
            h64^=(long)(UnsafeUtils.readByte(buf, off) & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }

    @Override
    public long hash(ByteBuffer buf, int off, int len, long seed) {
        long h64;
        if (buf.hasArray()) {
            return this.hash(buf.array(), off, len, seed);
        }
        ByteBufferUtils.checkRange(buf, off, len);
        buf = ByteBufferUtils.inLittleEndianOrder(buf);
        int end = off + len;
        if (len >= 32) {
            int limit = end - 32;
            long v1 = seed + -7046029288634856825L + -4417276706812531889L;
            long v2 = seed + -4417276706812531889L;
            long v3 = seed + 0;
            long v4 = seed - -7046029288634856825L;
            do {
                v1+=ByteBufferUtils.readLongLE(buf, off) * -4417276706812531889L;
                v1 = Long.rotateLeft(v1, 31);
                v1*=-7046029288634856825L;
                v2+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v2 = Long.rotateLeft(v2, 31);
                v2*=-7046029288634856825L;
                v3+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v3 = Long.rotateLeft(v3, 31);
                v3*=-7046029288634856825L;
                v4+=ByteBufferUtils.readLongLE(buf, off+=8) * -4417276706812531889L;
                v4 = Long.rotateLeft(v4, 31);
                v4*=-7046029288634856825L;
            } while ((off+=8) <= limit);
            h64 = Long.rotateLeft(v1, 1) + Long.rotateLeft(v2, 7) + Long.rotateLeft(v3, 12) + Long.rotateLeft(v4, 18);
            v1*=-4417276706812531889L;
            v1 = Long.rotateLeft(v1, 31);
            h64^=(v1*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v2*=-4417276706812531889L;
            v2 = Long.rotateLeft(v2, 31);
            h64^=(v2*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v3*=-4417276706812531889L;
            v3 = Long.rotateLeft(v3, 31);
            h64^=(v3*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
            v4*=-4417276706812531889L;
            v4 = Long.rotateLeft(v4, 31);
            h64^=(v4*=-7046029288634856825L);
            h64 = h64 * -7046029288634856825L + -8796714831421723037L;
        } else {
            h64 = seed + 2870177450012600261L;
        }
        h64+=(long)len;
        while (off <= end - 8) {
            long k1 = ByteBufferUtils.readLongLE(buf, off);
            k1*=-4417276706812531889L;
            k1 = Long.rotateLeft(k1, 31);
            h64^=(k1*=-7046029288634856825L);
            h64 = Long.rotateLeft(h64, 27) * -7046029288634856825L + -8796714831421723037L;
            off+=8;
        }
        if (off <= end - 4) {
            h64^=((long)ByteBufferUtils.readIntLE(buf, off) & 0xFFFFFFFFL) * -7046029288634856825L;
            h64 = Long.rotateLeft(h64, 23) * -4417276706812531889L + 1609587929392839161L;
            off+=4;
        }
        while (off < end) {
            h64^=(long)(ByteBufferUtils.readByte(buf, off) & 255) * 2870177450012600261L;
            h64 = Long.rotateLeft(h64, 11) * -7046029288634856825L;
            ++off;
        }
        h64^=h64 >>> 33;
        h64*=-4417276706812531889L;
        h64^=h64 >>> 29;
        h64*=1609587929392839161L;
        h64^=h64 >>> 32;
        return h64;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

final class XXHashConstants
extends Enum<XXHashConstants> {
    static final int PRIME1 = -1640531535;
    static final int PRIME2 = -2048144777;
    static final int PRIME3 = -1028477379;
    static final int PRIME4 = 668265263;
    static final int PRIME5 = 374761393;
    static final long PRIME64_1 = -7046029288634856825L;
    static final long PRIME64_2 = -4417276706812531889L;
    static final long PRIME64_3 = 1609587929392839161L;
    static final long PRIME64_4 = -8796714831421723037L;
    static final long PRIME64_5 = 2870177450012600261L;
    private static final /* synthetic */ XXHashConstants[] $VALUES;

    public static XXHashConstants[] values() {
        return (XXHashConstants[])$VALUES.clone();
    }

    public static XXHashConstants valueOf(String name) {
        return (XXHashConstants)Enum.valueOf(XXHashConstants.class, name);
    }

    private XXHashConstants() {
        super(string, n);
    }

    static {
        $VALUES = new XXHashConstants[0];
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.io.PrintStream;
import java.util.Random;
import net.jpountz.util.Native;
import net.jpountz.util.Utils;
import net.jpountz.xxhash.StreamingXXHash32;
import net.jpountz.xxhash.StreamingXXHash64;
import net.jpountz.xxhash.XXHash32;
import net.jpountz.xxhash.XXHash64;

public final class XXHashFactory {
    private static XXHashFactory NATIVE_INSTANCE;
    private static XXHashFactory JAVA_UNSAFE_INSTANCE;
    private static XXHashFactory JAVA_SAFE_INSTANCE;
    private final String impl;
    private final XXHash32 hash32;
    private final XXHash64 hash64;
    private final StreamingXXHash32.Factory streamingHash32Factory;
    private final StreamingXXHash64.Factory streamingHash64Factory;

    private static XXHashFactory instance(String impl) {
        try {
            return new XXHashFactory(impl);
        }
        catch (Exception e) {
            throw new AssertionError(e);
        }
    }

    public static synchronized XXHashFactory nativeInstance() {
        if (NATIVE_INSTANCE == null) {
            NATIVE_INSTANCE = XXHashFactory.instance("JNI");
        }
        return NATIVE_INSTANCE;
    }

    public static synchronized XXHashFactory safeInstance() {
        if (JAVA_SAFE_INSTANCE == null) {
            JAVA_SAFE_INSTANCE = XXHashFactory.instance("JavaSafe");
        }
        return JAVA_SAFE_INSTANCE;
    }

    public static synchronized XXHashFactory unsafeInstance() {
        if (JAVA_UNSAFE_INSTANCE == null) {
            JAVA_UNSAFE_INSTANCE = XXHashFactory.instance("JavaUnsafe");
        }
        return JAVA_UNSAFE_INSTANCE;
    }

    public static XXHashFactory fastestJavaInstance() {
        if (Utils.isUnalignedAccessAllowed()) {
            try {
                return XXHashFactory.unsafeInstance();
            }
            catch (Throwable t) {
                return XXHashFactory.safeInstance();
            }
        }
        return XXHashFactory.safeInstance();
    }

    public static XXHashFactory fastestInstance() {
        if (Native.isLoaded() || Native.class.getClassLoader() == ClassLoader.getSystemClassLoader()) {
            try {
                return XXHashFactory.nativeInstance();
            }
            catch (Throwable t) {
                return XXHashFactory.fastestJavaInstance();
            }
        }
        return XXHashFactory.fastestJavaInstance();
    }

    private static <T> T classInstance(String cls) throws NoSuchFieldException, SecurityException, ClassNotFoundException, IllegalArgumentException, IllegalAccessException {
        Class c = XXHashFactory.class.getClassLoader().loadClass(cls);
        Field f = c.getField("INSTANCE");
        return (T)f.get(null);
    }

    private XXHashFactory(String impl) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
        this.impl = impl;
        this.hash32 = (XXHash32)XXHashFactory.classInstance("net.jpountz.xxhash.XXHash32" + impl);
        this.streamingHash32Factory = (StreamingXXHash32.Factory)XXHashFactory.classInstance("net.jpountz.xxhash.StreamingXXHash32" + impl + "$Factory");
        this.hash64 = (XXHash64)XXHashFactory.classInstance("net.jpountz.xxhash.XXHash64" + impl);
        this.streamingHash64Factory = (StreamingXXHash64.Factory)XXHashFactory.classInstance("net.jpountz.xxhash.StreamingXXHash64" + impl + "$Factory");
        byte[] bytes = new byte[100];
        Random random = new Random();
        random.nextBytes(bytes);
        int seed = random.nextInt();
        int h1 = this.hash32.hash(bytes, 0, bytes.length, seed);
        StreamingXXHash32 streamingHash32 = this.newStreamingHash32(seed);
        streamingHash32.update(bytes, 0, bytes.length);
        int h2 = streamingHash32.getValue();
        long h3 = this.hash64.hash(bytes, 0, bytes.length, (long)seed);
        StreamingXXHash64 streamingHash64 = this.newStreamingHash64(seed);
        streamingHash64.update(bytes, 0, bytes.length);
        long h4 = streamingHash64.getValue();
        if (h1 != h2) {
            throw new AssertionError();
        }
        if (h3 != h4) {
            throw new AssertionError();
        }
    }

    public XXHash32 hash32() {
        return this.hash32;
    }

    public XXHash64 hash64() {
        return this.hash64;
    }

    public StreamingXXHash32 newStreamingHash32(int seed) {
        return this.streamingHash32Factory.newStreamingHash(seed);
    }

    public StreamingXXHash64 newStreamingHash64(long seed) {
        return this.streamingHash64Factory.newStreamingHash(seed);
    }

    public static void main(String[] args) {
        System.out.println("Fastest instance is " + XXHashFactory.fastestInstance());
        System.out.println("Fastest Java instance is " + XXHashFactory.fastestJavaInstance());
    }

    public String toString() {
        return this.getClass().getSimpleName() + ":" + this.impl;
    }
}

/*
 * Decompiled with CFR 0_101.
 */
package net.jpountz.xxhash;

import java.nio.ByteBuffer;
import net.jpountz.util.Native;

final class XXHashJNI
extends Enum<XXHashJNI> {
    private static final /* synthetic */ XXHashJNI[] $VALUES;

    public static XXHashJNI[] values() {
        return (XXHashJNI[])$VALUES.clone();
    }

    public static XXHashJNI valueOf(String name) {
        return (XXHashJNI)Enum.valueOf(XXHashJNI.class, name);
    }

    private XXHashJNI() {
        super(string, n);
    }

    private static native void init();

    static native int XXH32(byte[] var0, int var1, int var2, int var3);

    static native int XXH32BB(ByteBuffer var0, int var1, int var2, int var3);

    static native long XXH32_init(int var0);

    static native void XXH32_update(long var0, byte[] var2, int var3, int var4);

    static native int XXH32_digest(long var0);

    static native void XXH32_free(long var0);

    static native long XXH64(byte[] var0, int var1, int var2, long var3);

    static native long XXH64BB(ByteBuffer var0, int var1, int var2, long var3);

    static native long XXH64_init(long var0);

    static native void XXH64_update(long var0, byte[] var2, int var3, int var4);

    static native long XXH64_digest(long var0);

    static native void XXH64_free(long var0);

    static {
        $VALUES = new XXHashJNI[0];
        Native.load();
        XXHashJNI.init();
    }
}

